const PROBLEMS_DATA = [
  {
    "name": "Arrays and Hashing",
    "icon": "grid_view",
    "problems": [
      {
        "number": 1,
        "title": "Two Sum",
        "url": "https://leetcode.com/problems/two-sum/",
        "intuition": "For each number, its required complement (target \u2212 num) is known. A hash map lets you check in O(1) whether that complement was seen earlier.",
        "time": "O(n)",
        "space": "O(n)",
        "code": "\"\"\"\n1. Two Sum\nhttps://leetcode.com/problems/two-sum/\n\nGiven an array of integers nums and an integer target, return the indices\nof the two numbers that add up to target.\n\nKey Intuition:\n    For each number, its required complement (target \u2212 num) is known.\n    A hash map lets you check in O(1) whether that complement was seen earlier.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: One\u2011pass hash map\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}  # value -> index\n        for i, n in enumerate(nums):\n            complement = target - n\n            if complement in seen:\n                return [seen[complement], i]\n            seen[n] = i\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Brute force\n# Time O(n\u00b2) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBrute:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n",
        "filename": "Two_Sum.py"
      },
      {
        "number": 49,
        "title": "Group Anagrams",
        "url": "https://leetcode.com/problems/group-anagrams/",
        "intuition": "All anagrams share the same sorted\u2011character signature. Use that signature as a hash\u2011map key to bucket words together in one pass.",
        "time": "O(n \u00b7 k log k)  \u2014 n strings of avg length k",
        "space": "O(n \u00b7 k)",
        "code": "\"\"\"\n49. Group Anagrams\nhttps://leetcode.com/problems/group-anagrams/\n\nGiven an array of strings strs, group the anagrams together.\n\nKey Intuition:\n    All anagrams share the same sorted\u2011character signature. Use that\n    signature as a hash\u2011map key to bucket words together in one pass.\n\nComplexity (Optimal):\n    Time:  O(n \u00b7 k log k)  \u2014 n strings of avg length k\n    Space: O(n \u00b7 k)\n\"\"\"\n\nfrom typing import List\nfrom collections import defaultdict\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Sorted\u2011string key\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        groups = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))\n            \n            # sorted() always returns list( )\n            #  s=\"eat\" --> ['a' ,'e','t']\n\n            # using tuple cause we need something Immutable \n            # as the key of list \n            # tuple is unchanged and Immutable \n            # list is mutable \n\n            groups[key].append(s)\n        return list(groups.values()) \n\n        # group.values() returns only values not keys\n        # and as the return type of the function is list\n        # so at last converted into list \n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Character\u2011count tuple key (avoids sorting)\n# Time O(n \u00b7 k) \u00b7 Space O(n \u00b7 k)  \u2014 k bounded by 26 for lowercase\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionCount:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        groups = defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            groups[tuple(count)].append(s)\n        return list(groups.values())\n",
        "filename": "Group_Anagrams.py"
      },
      {
        "number": 128,
        "title": "Longest Consecutive Sequence",
        "url": "https://leetcode.com/problems/longest-consecutive-sequence/",
        "intuition": "Put all numbers in a set. A number is the *start* of a sequence only if (num \u2212 1) is NOT in the set. From each start, count upward. Every element is visited at most twice \u2192 O(n).",
        "time": "O(n)",
        "space": "O(n)",
        "code": "\"\"\"\n128. Longest Consecutive Sequence\nhttps://leetcode.com/problems/longest-consecutive-sequence/\n\nGiven an unsorted array of integers nums, return the length of the longest\nconsecutive elements sequence. Must run in O(n) time.\n\nKey Intuition:\n    Put all numbers in a set. A number is the *start* of a sequence only\n    if (num \u2212 1) is NOT in the set. From each start, count upward.\n    Every element is visited at most twice \u2192 O(n).\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Hash set with smart start detection\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        num_set = set(nums)\n        longest = 0\n\n        for n in num_set:\n            # Only start counting from the beginning of a sequence\n            if n - 1 not in num_set:\n                length = 1\n                while n + length in num_set:\n                    length += 1\n                longest = max(longest, length)\n\n        return longest\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Sorting\n# Time O(n log n) \u00b7 Space O(1) or O(n) depending on sort\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSort:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        nums.sort()\n        longest = cur_len = 1\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                continue  # skip duplicates\n            if nums[i] == nums[i - 1] + 1:\n                cur_len += 1\n            else:\n                cur_len = 1\n            longest = max(longest, cur_len)\n        return longest\n",
        "filename": "Longest_Consecutive_Sequence.py"
      },
      {
        "number": 217,
        "title": "Contains Duplicate",
        "url": "https://leetcode.com/problems/contains-duplicate/",
        "intuition": "A set only stores unique elements \u2014 if its size differs from the array's, a duplicate exists. Converting to a set gives O(1) lookups.",
        "time": "O(n)",
        "space": "O(n)",
        "code": "\"\"\"\n217. Contains Duplicate\nhttps://leetcode.com/problems/contains-duplicate/\n\nGiven an integer array nums, return true if any value appears at least twice\nin the array, and return false if every element is distinct.\n\nKey Intuition:\n    A set only stores unique elements \u2014 if its size differs from the array's,\n    a duplicate exists. Converting to a set gives O(1) lookups.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Hash Set\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        return len(nums) != len(set(nums))\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative 1: Early\u2011exit with a growing set\n# Time O(n) \u00b7 Space O(n) \u2014 faster in practice when duplicates are near the start\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionEarlyExit:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        seen = set()\n        for n in nums:\n            if n in seen:\n                return True\n            seen.add(n)\n        return False\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative 2: Sorting\n# Time O(n log n) \u00b7 Space O(1) if in-place sort allowed\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSort:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                return True\n        return False\n",
        "filename": "Contains_Duplicate.py"
      },
      {
        "number": 238,
        "title": "Product of Array Except Self",
        "url": "https://leetcode.com/problems/product-of-array-except-self/",
        "intuition": "For each index, the answer is (product of everything to its left) \u00d7 (product of everything to its right). Two passes \u2014 one forward, one backward \u2014 build these prefix/suffix products in\u2011place.",
        "time": "O(n)",
        "space": "O(1)  \u2014 output array doesn't count as extra space",
        "code": "\"\"\"\n238. Product of Array Except Self\nhttps://leetcode.com/problems/product-of-array-except-self/\n\nGiven an integer array nums, return an array answer such that answer[i]\nequals the product of all elements except nums[i], without using division.\n\nKey Intuition:\n    For each index, the answer is (product of everything to its left) \u00d7\n    (product of everything to its right). Two passes \u2014 one forward, one\n    backward \u2014 build these prefix/suffix products in\u2011place.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)  \u2014 output array doesn't count as extra space\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Prefix & suffix in a single output array\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        answer = [1] * n\n\n        # Forward pass: answer[i] = product of nums[0..i-1]\n        prefix = 1\n        for i in range(n):\n            answer[i] = prefix\n            prefix *= nums[i]\n\n        # Backward pass: multiply by product of nums[i+1..n-1]\n        suffix = 1\n        for i in range(n - 1, -1, -1):\n            answer[i] *= suffix\n            suffix *= nums[i]\n\n        return answer\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Separate prefix & suffix arrays (clearer, same time)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionExplicit:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix = [1] * n\n        suffix = [1] * n\n\n        for i in range(1, n):\n            prefix[i] = prefix[i - 1] * nums[i - 1]\n        for i in range(n - 2, -1, -1):\n            suffix[i] = suffix[i + 1] * nums[i + 1]\n\n        return [prefix[i] * suffix[i] for i in range(n)]\n",
        "filename": "Product_of_Array_Except_Self.py"
      },
      {
        "number": 242,
        "title": "Valid Anagram",
        "url": "https://leetcode.com/problems/valid-anagram/",
        "intuition": "Two strings are anagrams iff they share the exact same character frequencies. Counter comparison does this in one pass.",
        "time": "O(n)  \u2014 n = len(s) + len(t)",
        "space": "O(1)  \u2014 at most 26 lowercase letters",
        "code": "\"\"\"\n242. Valid Anagram\nhttps://leetcode.com/problems/valid-anagram/\n\nGiven two strings s and t, return true if t is an anagram of s.\n\nKey Intuition:\n    Two strings are anagrams iff they share the exact same character\n    frequencies. Counter comparison does this in one pass.\n\nComplexity (Optimal):\n    Time:  O(n)  \u2014 n = len(s) + len(t)\n    Space: O(1)  \u2014 at most 26 lowercase letters\n\"\"\"\n\nfrom collections import Counter\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Counter comparison\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return Counter(s) == Counter(t)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Manual frequency array (no imports)\n# Time O(n) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionManual:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        count = [0] * 26\n        for a, b in zip(s, t):\n            count[ord(a) - ord('a')] += 1\n            count[ord(b) - ord('a')] -= 1\n        return all(c == 0 for c in count)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Sorting\n# Time O(n log n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSort:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return sorted(s) == sorted(t)\n",
        "filename": "Valid_Anagram.py"
      },
      {
        "number": 271,
        "title": "Encode and Decode Strings",
        "url": "https://leetcode.com/problems/encode-and-decode-strings/",
        "intuition": "Prefix each string with its length and a delimiter (e.g. \"4#word\"). This avoids any escaping issues because the length tells you exactly how many characters to consume.",
        "time": "O(n) for both encode and decode \u2014 n = total chars across all strings",
        "space": "O(n)",
        "code": "\"\"\"\n271. Encode and Decode Strings (LeetCode Premium / LintCode 659)\nhttps://leetcode.com/problems/encode-and-decode-strings/\n\nDesign an algorithm to encode a list of strings to a single string and\ndecode it back to the original list.\n\nKey Intuition:\n    Prefix each string with its length and a delimiter (e.g. \"4#word\").\n    This avoids any escaping issues because the length tells you exactly\n    how many characters to consume.\n\nComplexity:\n    Time:  O(n) for both encode and decode \u2014 n = total chars across all strings\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\n\n\nclass Codec:\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    # Optimal: Length\u2011prefixed encoding\n    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    def encode(self, strs: List[str]) -> str:\n        return ''.join(f'{len(s)}#{s}' for s in strs)\n\n    def decode(self, s: str) -> List[str]:\n        result, i = [], 0\n        while i < len(s):\n            j = s.index('#', i)          # find delimiter\n            length = int(s[i:j])          # parse length\n            result.append(s[j + 1: j + 1 + length])\n            i = j + 1 + length\n        return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Escaping\u2011based approach\n# Use a special separator (e.g. \"/;\") and escape any \"/\" in the\n# original strings with \"//\". Decode by splitting and un\u2011escaping.\n# More error\u2011prone; length\u2011prefix is preferred in interviews.\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass CodecEscape:\n    def encode(self, strs: List[str]) -> str:\n        return '/;'.join(s.replace('/', '//') for s in strs)\n\n    def decode(self, s: str) -> List[str]:\n        # This simplified version has edge\u2011case issues \u2014\n        # length\u2011prefix is strictly better.\n        parts = s.split('/;')\n        return [p.replace('//', '/') for p in parts]\n",
        "filename": "Encode_and_Decode_Strings.py"
      },
      {
        "number": 347,
        "title": "Top K Frequent Elements",
        "url": "https://leetcode.com/problems/top-k-frequent-elements/",
        "intuition": "Bucket sort by frequency: index = frequency, value = list of numbers with that frequency. Walk buckets from high to low to collect top\u2011k in O(n) time \u2014 no heap needed.",
        "time": "O(n)",
        "space": "O(n)",
        "code": "\"\"\"\n347. Top K Frequent Elements\nhttps://leetcode.com/problems/top-k-frequent-elements/\n\nGiven an integer array nums and an integer k, return the k most frequent\nelements. Answer may be in any order.\n\nKey Intuition:\n    Bucket sort by frequency: index = frequency, value = list of numbers\n    with that frequency. Walk buckets from high to low to collect top\u2011k\n    in O(n) time \u2014 no heap needed.\n\nComplexity (Optimal \u2013 Bucket Sort):\n    Time:  O(n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\nfrom collections import Counter\nimport heapq\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bucket sort by frequency\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = Counter(nums)\n        # bucket[i] holds numbers that appear exactly i times\n        bucket = [[] for _ in range(len(nums) + 1)]\n        for num, freq in count.items():\n            bucket[freq].append(num)\n\n        result = []\n        for freq in range(len(bucket) - 1, 0, -1):\n            for num in bucket[freq]:\n                result.append(num)\n                if len(result) == k:\n                    return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Min\u2011heap of size k\n# Time O(n log k) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionHeap:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = Counter(nums)\n        return heapq.nlargest(k, count.keys(), key=count.get)\n",
        "filename": "Top_K_Frequent_Elements.py"
      }
    ]
  },
  {
    "name": "Two Pointers",
    "icon": "compare_arrows",
    "problems": [
      {
        "number": 11,
        "title": "Container With Most Water",
        "url": "https://leetcode.com/problems/container-with-most-water/",
        "intuition": "Start with the widest container (left, right ends). The only way to potentially find a larger area is to move the *shorter* line inward, because moving the taller one can never increase the limiting height.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n11. Container With Most Water\nhttps://leetcode.com/problems/container-with-most-water/\n\nGiven n non\u2011negative integers where each represents a vertical line,\nfind two lines that together with the x\u2011axis form a container that\nholds the most water.\n\nKey Intuition:\n    Start with the widest container (left, right ends). The only way to\n    potentially find a larger area is to move the *shorter* line inward,\n    because moving the taller one can never increase the limiting height.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Two Pointers (greedy)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        max_water = 0\n        while l < r:\n            w = r - l\n            h = min(height[l], height[r])\n            max_water = max(max_water, w * h)\n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n        return max_water\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Brute force (for reference only \u2014 TLE on large inputs)\n# Time O(n\u00b2) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBrute:\n    def maxArea(self, height: List[int]) -> int:\n        max_water = 0\n        for i in range(len(height)):\n            for j in range(i + 1, len(height)):\n                max_water = max(max_water, (j - i) * min(height[i], height[j]))\n        return max_water\n",
        "filename": "Container_With_Most_Water.py"
      },
      {
        "number": 15,
        "title": "3Sum",
        "url": "https://leetcode.com/problems/3sum/",
        "intuition": "Sort the array, fix one element, then use two pointers on the remaining subarray to find pairs that sum to its negation. Skip duplicates at every level to avoid repeated triplets.",
        "time": "O(n\u00b2)",
        "space": "O(1)  \u2014 ignoring output storage; sort is in\u2011place",
        "code": "\"\"\"\n15. 3Sum\nhttps://leetcode.com/problems/3sum/\n\nGiven an integer array nums, return all unique triplets [a, b, c] such\nthat a + b + c = 0.\n\nKey Intuition:\n    Sort the array, fix one element, then use two pointers on the\n    remaining subarray to find pairs that sum to its negation.\n    Skip duplicates at every level to avoid repeated triplets.\n\nComplexity (Optimal):\n    Time:  O(n\u00b2)\n    Space: O(1)  \u2014 ignoring output storage; sort is in\u2011place\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Sort + Two Pointers\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 2):\n            # Skip duplicate for the first element\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            # Early termination: smallest triplet already > 0\n            if nums[i] > 0:\n                break\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                total = nums[i] + nums[l] + nums[r]\n                if total < 0:\n                    l += 1\n                elif total > 0:\n                    r -= 1\n                else:\n                    result.append([nums[i], nums[l], nums[r]])\n                    # Skip duplicates\n                    while l < r and nums[l] == nums[l + 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r - 1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Hash set approach (less common in interviews)\n# Time O(n\u00b2) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionHashSet:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            seen = set()\n            j = i + 1\n            while j < len(nums):\n                complement = -nums[i] - nums[j]\n                if complement in seen:\n                    result.append([nums[i], complement, nums[j]])\n                    while j + 1 < len(nums) and nums[j] == nums[j + 1]:\n                        j += 1\n                seen.add(nums[j])\n                j += 1\n        return result\n",
        "filename": "3Sum.py"
      },
      {
        "number": 125,
        "title": "Valid Palindrome",
        "url": "https://leetcode.com/problems/valid-palindrome/",
        "intuition": "Use two pointers from the outside inward, skipping non\u2011alphanumeric characters and comparing case\u2011insensitively. No need to build a cleaned string first.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n\nGiven a string s, return true if it is a palindrome after converting to\nlowercase and removing non\u2011alphanumeric characters.\n\nKey Intuition:\n    Use two pointers from the outside inward, skipping non\u2011alphanumeric\n    characters and comparing case\u2011insensitively. No need to build a\n    cleaned string first.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Two pointers, in\u2011place\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and not s[l].isalnum():\n                l += 1\n            while l < r and not s[r].isalnum():\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l += 1\n            r -= 1\n        return True\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Pythonic one\u2011liner (builds cleaned string)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionPythonic:\n    def isPalindrome(self, s: str) -> bool:\n        cleaned = ''.join(c.lower() for c in s if c.isalnum())\n        return cleaned == cleaned[::-1]\n",
        "filename": "Valid_Palindrome.py"
      }
    ]
  },
  {
    "name": "Sliding Window",
    "icon": "swap_horiz",
    "problems": [
      {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
        "intuition": "Expand a sliding window to the right. When a duplicate is found, shrink from the left until all characters in the window are unique. A set tracks the current window's characters.",
        "time": "O(n)",
        "space": "O(min(n, m))  \u2014 m = size of the character set",
        "code": "\"\"\"\n3. Longest Substring Without Repeating Characters\nhttps://leetcode.com/problems/longest-substring-without-repeating-characters/\n\nGiven a string s, find the length of the longest substring without\nrepeating characters.\n\nKey Intuition:\n    Expand a sliding window to the right. When a duplicate is found,\n    shrink from the left until all characters in the window are unique.\n    A set tracks the current window's characters.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(min(n, m))  \u2014 m = size of the character set\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Sliding window with a set\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_set = set()\n        l = 0\n        longest = 0\n        for r in range(len(s)):\n            while s[r] in char_set:\n                char_set.remove(s[l])\n                l += 1\n            char_set.add(s[r])\n            longest = max(longest, r - l + 1)\n        return longest\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Sliding window with last\u2011seen index map (jump left pointer)\n# Time O(n) \u00b7 Space O(min(n, m))\n# Slightly faster because left pointer can jump instead of sliding.\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionMap:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        last_seen = {}\n        l = 0\n        longest = 0\n        for r, ch in enumerate(s):\n            if ch in last_seen and last_seen[ch] >= l:\n                l = last_seen[ch] + 1\n            last_seen[ch] = r\n            longest = max(longest, r - l + 1)\n        return longest\n",
        "filename": "Longest_Substring_Without_Repeating_Characters.py"
      },
      {
        "number": 76,
        "title": "Minimum Window Substring",
        "url": "https://leetcode.com/problems/minimum-window-substring/",
        "intuition": "Use a sliding window: expand right to satisfy the requirement, then shrink left to minimize the window. Track how many unique characters still need to be fulfilled (\"need\" counter) vs. how many are already satisfied (\"have\" counter).",
        "time": "O(|s| + |t|)",
        "space": "O(|s| + |t|)",
        "code": "\"\"\"\n76. Minimum Window Substring\nhttps://leetcode.com/problems/minimum-window-substring/\n\nGiven strings s and t, return the minimum window in s that contains\nevery character of t (including duplicates). Return \"\" if no such window.\n\nKey Intuition:\n    Use a sliding window: expand right to satisfy the requirement, then\n    shrink left to minimize the window. Track how many unique characters\n    still need to be fulfilled (\"need\" counter) vs. how many are already\n    satisfied (\"have\" counter).\n\nComplexity (Optimal):\n    Time:  O(|s| + |t|)\n    Space: O(|s| + |t|)\n\"\"\"\n\nfrom collections import Counter\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Sliding window with two frequency maps\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n\n        count_t = Counter(t)\n        required = len(count_t)  # unique chars we need\n\n        window = {}\n        have = 0        # how many unique chars meet the required count\n        l = 0\n        res, res_len = [-1, -1], float('inf')\n\n        for r in range(len(s)):\n            ch = s[r]\n            window[ch] = window.get(ch, 0) + 1\n\n            if ch in count_t and window[ch] == count_t[ch]:\n                have += 1\n\n            while have == required:\n                # Update result\n                if (r - l + 1) < res_len:\n                    res = [l, r]\n                    res_len = r - l + 1\n                # Shrink from the left\n                window[s[l]] -= 1\n                if s[l] in count_t and window[s[l]] < count_t[s[l]]:\n                    have -= 1\n                l += 1\n\n        return s[res[0]: res[1] + 1] if res_len != float('inf') else \"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Optimized with filtered s (skip irrelevant chars)\n# Time O(|s| + |t|) but faster constant when |s| >> |t|\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionFiltered:\n    def minWindow(self, s: str, t: str) -> str:\n        if not t or not s:\n            return \"\"\n\n        count_t = Counter(t)\n        required = len(count_t)\n\n        # Only keep characters in s that are in t, with their original indices\n        filtered = [(i, ch) for i, ch in enumerate(s) if ch in count_t]\n\n        window = {}\n        have = 0\n        l = 0\n        res, res_len = [-1, -1], float('inf')\n\n        for r in range(len(filtered)):\n            ch = filtered[r][1]\n            window[ch] = window.get(ch, 0) + 1\n\n            if window[ch] == count_t[ch]:\n                have += 1\n\n            while have == required:\n                start = filtered[l][0]\n                end = filtered[r][0]\n                if (end - start + 1) < res_len:\n                    res = [start, end]\n                    res_len = end - start + 1\n\n                left_ch = filtered[l][1]\n                window[left_ch] -= 1\n                if window[left_ch] < count_t[left_ch]:\n                    have -= 1\n                l += 1\n\n        return s[res[0]: res[1] + 1] if res_len != float('inf') else \"\"\n",
        "filename": "Minimum_Window_Substring.py"
      },
      {
        "number": 121,
        "title": "Best Time to Buy and Sell Stock",
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
        "intuition": "Track the minimum price seen so far. At each day, the best profit you could make by selling today is (price \u2212 min_so_far). Keep the running maximum of that profit.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n121. Best Time to Buy and Sell Stock\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/\n\nGiven an array prices where prices[i] is the price on the i\u2011th day,\nmaximize profit from one buy and one sell (buy before sell).\n\nKey Intuition:\n    Track the minimum price seen so far. At each day, the best profit\n    you could make by selling today is (price \u2212 min_so_far). Keep the\n    running maximum of that profit.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: One\u2011pass, track min price\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Sliding\u2011window / two\u2011pointer view\n# Time O(n) \u00b7 Space O(1)\n# Same idea expressed with left (buy) and right (sell) pointers\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionTwoPointer:\n    def maxProfit(self, prices: List[int]) -> int:\n        l, r = 0, 1\n        max_profit = 0\n        while r < len(prices):\n            if prices[l] < prices[r]:\n                max_profit = max(max_profit, prices[r] - prices[l])\n            else:\n                l = r   # found a new minimum\n            r += 1\n        return max_profit\n",
        "filename": "Best_Time_to_Buy_and_Sell_Stock.py"
      },
      {
        "number": 424,
        "title": "Longest Repeating Character Replacement",
        "url": "https://leetcode.com/problems/longest-repeating-character-replacement/",
        "intuition": "In any valid window, (window_length \u2212 count_of_most_frequent_char) \u2264 k. Expand right; when the condition breaks, shrink left. You don't need to decrement max_freq when shrinking because only a *larger* max_freq can ever produce a longer answer.",
        "time": "O(n)",
        "space": "O(1)  \u2014 at most 26 letter counts",
        "code": "\"\"\"\n424. Longest Repeating Character Replacement\nhttps://leetcode.com/problems/longest-repeating-character-replacement/\n\nGiven a string s and an integer k, you can replace at most k characters.\nReturn the length of the longest substring containing the same letter.\n\nKey Intuition:\n    In any valid window, (window_length \u2212 count_of_most_frequent_char) \u2264 k.\n    Expand right; when the condition breaks, shrink left. You don't need\n    to decrement max_freq when shrinking because only a *larger* max_freq\n    can ever produce a longer answer.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)  \u2014 at most 26 letter counts\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Sliding window\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        l = 0\n        max_freq = 0\n        result = 0\n\n        for r in range(len(s)):\n            count[s[r]] = count.get(s[r], 0) + 1\n            max_freq = max(max_freq, count[s[r]])\n\n            # Window is invalid: more replacements needed than k\n            while (r - l + 1) - max_freq > k:\n                count[s[l]] -= 1\n                l += 1\n\n            result = max(result, r - l + 1)\n\n        return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Binary search on answer length + sliding window check\n# Time O(n log n) \u00b7 Space O(1)\n# For each candidate length, slide a window and check feasibility.\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBinarySearch:\n    def characterReplacement(self, s: str, k: int) -> int:\n        def can_make(length: int) -> bool:\n            count = {}\n            for r in range(len(s)):\n                count[s[r]] = count.get(s[r], 0) + 1\n                if r >= length:\n                    count[s[r - length]] -= 1\n                    if count[s[r - length]] == 0:\n                        del count[s[r - length]]\n                if r >= length - 1:\n                    if length - max(count.values()) <= k:\n                        return True\n            return False\n\n        lo, hi, ans = 1, len(s), 0\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if can_make(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return ans\n",
        "filename": "Longest_Repeating_Character_Replacement.py"
      }
    ]
  },
  {
    "name": "Stack",
    "icon": "layers",
    "problems": [
      {
        "number": 20,
        "title": "Valid Parentheses",
        "url": "https://leetcode.com/problems/valid-parentheses/",
        "intuition": "A stack naturally mirrors the nesting structure of brackets. Push every opening bracket; on a closing bracket, check that the top of the stack is its matching opener.",
        "time": "O(n)",
        "space": "O(n)",
        "code": "\"\"\"\n20. Valid Parentheses\nhttps://leetcode.com/problems/valid-parentheses/\n\nGiven a string s containing just '(', ')', '{', '}', '[' and ']',\ndetermine if the input string is valid.\n\nKey Intuition:\n    A stack naturally mirrors the nesting structure of brackets.\n    Push every opening bracket; on a closing bracket, check that\n    the top of the stack is its matching opener.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Stack\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        close_to_open = {')': '(', ']': '[', '}': '{'}\n\n        for ch in s:\n            if ch in close_to_open:\n                if stack and stack[-1] == close_to_open[ch]:\n                    stack.pop()\n                else:\n                    return False\n            else:\n                stack.append(ch)\n\n        return not stack\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Replace pairs iteratively (fun but slow)\n# Time O(n\u00b2) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionReplace:\n    def isValid(self, s: str) -> bool:\n        while '()' in s or '[]' in s or '{}' in s:\n            s = s.replace('()', '').replace('[]', '').replace('{}', '')\n        return s == ''\n",
        "filename": "Valid_Parentheses.py"
      }
    ]
  },
  {
    "name": "Binary Search",
    "icon": "search",
    "problems": [
      {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
        "intuition": "At every binary search step, one half is always normally sorted. Determine which half is sorted, then check whether the target lies within that sorted range to decide which half to search.",
        "time": "O(log n)",
        "space": "O(1)",
        "code": "\"\"\"\n33. Search in Rotated Sorted Array\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/\n\nGiven a rotated sorted array of distinct integers and a target, return\nthe index of target or -1 if not found. Must run in O(log n).\n\nKey Intuition:\n    At every binary search step, one half is always normally sorted.\n    Determine which half is sorted, then check whether the target lies\n    within that sorted range to decide which half to search.\n\nComplexity (Optimal):\n    Time:  O(log n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Modified binary search\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n\n            # Left half is sorted\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            # Right half is sorted\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n\n        return -1\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Find pivot first, then standard binary search\n# Time O(log n) \u00b7 Space O(1) \u2014 two binary searches\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionTwoPass:\n    def search(self, nums: List[int], target: int) -> int:\n        # Step 1: find the index of the minimum element (pivot)\n        lo, hi = 0, len(nums) - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if nums[mid] > nums[hi]:\n                lo = mid + 1\n            else:\n                hi = mid\n        pivot = lo\n\n        # Step 2: standard binary search on the \"unrotated\" array\n        lo, hi = 0, len(nums) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            real_mid = (mid + pivot) % len(nums)\n            if nums[real_mid] == target:\n                return real_mid\n            elif nums[real_mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n",
        "filename": "Search_in_Rotated_Sorted_Array.py"
      },
      {
        "number": 153,
        "title": "Find Minimum in Rotated Sorted Array",
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
        "intuition": "The minimum is at the \"inflection point\" where the sorted order breaks. Binary search: if nums[mid] > nums[right], the min is in the right half; otherwise it's in the left half (including mid).",
        "time": "O(log n)",
        "space": "O(1)",
        "code": "\"\"\"\n153. Find Minimum in Rotated Sorted Array\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\n\nA sorted array of unique elements is rotated between 1 and n times.\nFind the minimum element. Must run in O(log n).\n\nKey Intuition:\n    The minimum is at the \"inflection point\" where the sorted order\n    breaks. Binary search: if nums[mid] > nums[right], the min is in\n    the right half; otherwise it's in the left half (including mid).\n\nComplexity (Optimal):\n    Time:  O(log n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Modified binary search\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1       # min is in right half\n            else:\n                r = mid           # min is mid or to the left\n        return nums[l]\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Linear scan (trivial but O(n))\n# Time O(n) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionLinear:\n    def findMin(self, nums: List[int]) -> int:\n        return min(nums)\n",
        "filename": "Find_Minimum_in_Rotated_Sorted_Array.py"
      }
    ]
  },
  {
    "name": "Linked List",
    "icon": "link",
    "problems": [
      {
        "number": 19,
        "title": "Remove Nth Node From End",
        "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
        "intuition": "Use two pointers separated by n nodes. When the fast pointer reaches the end, the slow pointer is right before the target node. A dummy node elegantly handles the edge case of removing the head.",
        "time": "O(L)  \u2014 L = length of the list",
        "space": "O(1)",
        "code": "\"\"\"\n19. Remove Nth Node From End of List\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/\n\nGiven the head of a linked list, remove the n\u2011th node from the end and\nreturn the head.\n\nKey Intuition:\n    Use two pointers separated by n nodes. When the fast pointer reaches\n    the end, the slow pointer is right before the target node.\n    A dummy node elegantly handles the edge case of removing the head.\n\nComplexity (Optimal):\n    Time:  O(L)  \u2014 L = length of the list\n    Space: O(1)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: One\u2011pass, two pointers\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def removeNthFromEnd(\n        self, head: Optional[ListNode], n: int\n    ) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        slow = fast = dummy\n\n        # Advance fast n + 1 steps so the gap is n\n        for _ in range(n + 1):\n            fast = fast.next\n\n        while fast:\n            slow = slow.next\n            fast = fast.next\n\n        slow.next = slow.next.next  # delete the target node\n        return dummy.next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Two\u2011pass (compute length first)\n# Time O(L) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionTwoPass:\n    def removeNthFromEnd(\n        self, head: Optional[ListNode], n: int\n    ) -> Optional[ListNode]:\n        # First pass: get length\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n\n        # Edge case: remove the head\n        if n == length:\n            return head.next\n\n        # Second pass: go to (length - n - 1)\u2011th node\n        cur = head\n        for _ in range(length - n - 1):\n            cur = cur.next\n        cur.next = cur.next.next\n        return head\n",
        "filename": "Remove_Nth_Node_From_End.py"
      },
      {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "url": "https://leetcode.com/problems/merge-two-sorted-lists/",
        "intuition": "Use a dummy head and a tail pointer. Compare the two current nodes; attach the smaller one and advance that list. Append whatever remains.",
        "time": "O(n + m)",
        "space": "O(1)",
        "code": "\"\"\"\n21. Merge Two Sorted Lists\nhttps://leetcode.com/problems/merge-two-sorted-lists/\n\nMerge two sorted linked lists into one sorted list made by splicing\ntogether the nodes of the two input lists.\n\nKey Intuition:\n    Use a dummy head and a tail pointer. Compare the two current nodes;\n    attach the smaller one and advance that list. Append whatever remains.\n\nComplexity (Optimal \u2013 Iterative):\n    Time:  O(n + m)\n    Space: O(1)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Iterative with dummy head\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def mergeTwoLists(\n        self, list1: Optional[ListNode], list2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n\n        while list1 and list2:\n            if list1.val <= list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n\n        tail.next = list1 or list2\n        return dummy.next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Recursive\n# Time O(n + m) \u00b7 Space O(n + m) \u2014 call stack\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionRecursive:\n    def mergeTwoLists(\n        self, list1: Optional[ListNode], list2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        if list1.val <= list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2\n",
        "filename": "Merge_Two_Sorted_Lists.py"
      },
      {
        "number": 23,
        "title": "Merge K Sorted Lists",
        "url": "https://leetcode.com/problems/merge-k-sorted-lists/",
        "intuition": "Use a min\u2011heap of size k to always pick the smallest current head. Push the next node of the chosen list back into the heap.",
        "time": "O(N log k)  \u2014 N = total nodes, k = number of lists",
        "space": "O(k)",
        "code": "\"\"\"\n23. Merge k Sorted Lists\nhttps://leetcode.com/problems/merge-k-sorted-lists/\n\nMerge k sorted linked lists into one sorted linked list.\n\nKey Intuition:\n    Use a min\u2011heap of size k to always pick the smallest current head.\n    Push the next node of the chosen list back into the heap.\n\nComplexity (Optimal \u2013 Heap):\n    Time:  O(N log k)  \u2014 N = total nodes, k = number of lists\n    Space: O(k)\n\"\"\"\n\nfrom typing import List, Optional\nimport heapq\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Min\u2011heap\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def mergeKLists(\n        self, lists: List[Optional[ListNode]]\n    ) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n\n        # (value, tie\u2011breaker index, node)\n        heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Divide and Conquer (merge pairs)\n# Time O(N log k) \u00b7 Space O(log k) \u2014 recursion depth\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDC:\n    def mergeKLists(\n        self, lists: List[Optional[ListNode]]\n    ) -> Optional[ListNode]:\n        if not lists:\n            return None\n        while len(lists) > 1:\n            merged = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\n                merged.append(self._merge2(l1, l2))\n            lists = merged\n        return lists[0]\n\n    def _merge2(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        tail.next = l1 or l2\n        return dummy.next\n",
        "filename": "Merge_K_Sorted_Lists.py"
      },
      {
        "number": 141,
        "title": "Linked List Cycle",
        "url": "https://leetcode.com/problems/linked-list-cycle/",
        "intuition": "Floyd's Tortoise and Hare: slow moves 1 step, fast moves 2 steps. If there's a cycle they will eventually meet; if not, fast reaches the end.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n141. Linked List Cycle\nhttps://leetcode.com/problems/linked-list-cycle/\n\nGiven head, determine if the linked list has a cycle.\n\nKey Intuition:\n    Floyd's Tortoise and Hare: slow moves 1 step, fast moves 2 steps.\n    If there's a cycle they will eventually meet; if not, fast reaches\n    the end.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Floyd's cycle detection\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow is fast:\n                return True\n        return False\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Hash set of visited nodes\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionHash:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        visited = set()\n        cur = head\n        while cur:\n            if cur in visited:\n                return True\n            visited.add(cur)\n            cur = cur.next\n        return False\n",
        "filename": "Linked_List_Cycle.py"
      },
      {
        "number": 143,
        "title": "Reorder List",
        "url": "https://leetcode.com/problems/reorder-list/",
        "intuition": "1. Find the middle using slow/fast pointers. 2. Reverse the second half. 3. Merge the two halves by alternating nodes.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n143. Reorder List\nhttps://leetcode.com/problems/reorder-list/\n\nReorder: L0 \u2192 Ln \u2192 L1 \u2192 Ln-1 \u2192 L2 \u2192 Ln-2 \u2192 \u2026\nDo not return anything, modify head in-place.\n\nKey Intuition:\n    1. Find the middle using slow/fast pointers.\n    2. Reverse the second half.\n    3. Merge the two halves by alternating nodes.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Split + Reverse + Merge\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        if not head or not head.next:\n            return\n\n        # 1. Find middle (slow ends at start of 2nd half)\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # 2. Reverse second half\n        second = slow.next\n        slow.next = None  # cut\n        prev = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n        second = prev  # head of reversed 2nd half\n\n        # 3. Merge two halves\n        first = head\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first = tmp1\n            second = tmp2\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Deque\u2011based (uses extra space)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfrom collections import deque\n\n\nclass SolutionDeque:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        if not head:\n            return\n        nodes = deque()\n        cur = head\n        while cur:\n            nodes.append(cur)\n            cur = cur.next\n\n        cur = nodes.popleft()\n        while nodes:\n            cur.next = nodes.pop()\n            cur = cur.next\n            if nodes:\n                cur.next = nodes.popleft()\n                cur = cur.next\n        cur.next = None\n",
        "filename": "Reorder_List.py"
      },
      {
        "number": 206,
        "title": "Reverse Linked List",
        "url": "https://leetcode.com/problems/reverse-linked-list/",
        "intuition": "Walk through the list, re\u2011pointing each node's `next` to its predecessor. Only three pointers are needed: prev, curr, next_temp.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n206. Reverse Linked List\nhttps://leetcode.com/problems/reverse-linked-list/\n\nGiven the head of a singly linked list, reverse and return its head.\n\nKey Intuition:\n    Walk through the list, re\u2011pointing each node's `next` to its\n    predecessor. Only three pointers are needed: prev, curr, next_temp.\n\nComplexity (Optimal \u2013 Iterative):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Iterative\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev, curr = None, head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Recursive\n# Time O(n) \u00b7 Space O(n) \u2014 call stack\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionRecursive:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        new_head = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return new_head\n",
        "filename": "Reverse_Linked_List.py"
      }
    ]
  },
  {
    "name": "Trees",
    "icon": "account_tree",
    "problems": [
      {
        "number": 98,
        "title": "Validate BST",
        "url": "https://leetcode.com/problems/validate-binary-search-tree/",
        "intuition": "Every node must fall within an allowed range (low, high). Going left tightens the upper bound; going right tightens the lower bound. Start with (-inf, inf).",
        "time": "O(n)",
        "space": "O(h)",
        "code": "\"\"\"\n98. Validate Binary Search Tree\nhttps://leetcode.com/problems/validate-binary-search-tree/\n\nGiven the root of a binary tree, determine if it is a valid BST.\n\nKey Intuition:\n    Every node must fall within an allowed range (low, high). Going left\n    tightens the upper bound; going right tightens the lower bound.\n    Start with (-inf, inf).\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(h)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: DFS with valid range\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def validate(node, low, high):\n            if not node:\n                return True\n            if not (low < node.val < high):\n                return False\n            return (validate(node.left, low, node.val) and\n                    validate(node.right, node.val, high))\n\n        return validate(root, float('-inf'), float('inf'))\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: In\u2011order traversal (should be strictly increasing)\n# Time O(n) \u00b7 Space O(h)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionInorder:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        self.prev = float('-inf')\n\n        def inorder(node):\n            if not node:\n                return True\n            if not inorder(node.left):\n                return False\n            if node.val <= self.prev:\n                return False\n            self.prev = node.val\n            return inorder(node.right)\n\n        return inorder(root)\n",
        "filename": "Validate_BST.py"
      },
      {
        "number": 100,
        "title": "Same Tree",
        "url": "https://leetcode.com/problems/same-tree/",
        "intuition": "Two trees are the same if their roots match and their left and right subtrees are recursively the same. Both being None is the base \"equal\" case.",
        "time": "O(n)",
        "space": "O(h)",
        "code": "\"\"\"\n100. Same Tree\nhttps://leetcode.com/problems/same-tree/\n\nGiven the roots of two binary trees, check if they are structurally\nidentical and have the same node values.\n\nKey Intuition:\n    Two trees are the same if their roots match and their left and right\n    subtrees are recursively the same. Both being None is the base \"equal\" case.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(h)\n\"\"\"\n\nfrom typing import Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: DFS recursive\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return (self.isSameTree(p.left, q.left) and\n                self.isSameTree(p.right, q.right))\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: BFS iterative\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBFS:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        queue = deque([(p, q)])\n        while queue:\n            n1, n2 = queue.popleft()\n            if not n1 and not n2:\n                continue\n            if not n1 or not n2 or n1.val != n2.val:\n                return False\n            queue.append((n1.left, n2.left))\n            queue.append((n1.right, n2.right))\n        return True\n",
        "filename": "Same_Tree.py"
      },
      {
        "number": 102,
        "title": "Binary Tree Level Order Traversal",
        "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
        "intuition": "BFS with a queue. Process nodes level\u2011by\u2011level: at each level, drain the current queue size and collect all values for that level.",
        "time": "O(n)",
        "space": "O(n)",
        "code": "\"\"\"\n102. Binary Tree Level Order Traversal\nhttps://leetcode.com/problems/binary-tree-level-order-traversal/\n\nGiven the root, return the level order traversal (values grouped by level).\n\nKey Intuition:\n    BFS with a queue. Process nodes level\u2011by\u2011level: at each level,\n    drain the current queue size and collect all values for that level.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import Optional, List\nfrom collections import deque\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: BFS with queue\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n\n        result = []\n        queue = deque([root])\n\n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n\n        return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DFS recursive (track depth)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDFS:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        result = []\n\n        def dfs(node, depth):\n            if not node:\n                return\n            if depth == len(result):\n                result.append([])\n            result[depth].append(node.val)\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n\n        dfs(root, 0)\n        return result\n",
        "filename": "Binary_Tree_Level_Order_Traversal.py"
      },
      {
        "number": 104,
        "title": "Max Depth",
        "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
        "intuition": "The depth of a tree is 1 + max(depth of left, depth of right). Base case: empty tree has depth 0.",
        "time": "O(n)",
        "space": "O(h)",
        "code": "\"\"\"\n104. Maximum Depth of Binary Tree\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\n\nGiven the root of a binary tree, return its maximum depth (longest\nroot\u2011to\u2011leaf path in number of nodes).\n\nKey Intuition:\n    The depth of a tree is 1 + max(depth of left, depth of right).\n    Base case: empty tree has depth 0.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(h)\n\"\"\"\n\nfrom typing import Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: DFS recursive\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: BFS level\u2011order (count levels)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBFS:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        depth = 0\n        queue = deque([root])\n        while queue:\n            depth += 1\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return depth\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Iterative DFS with stack\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionIterDFS:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        stack = [(root, 1)]\n        max_d = 0\n        while stack:\n            node, depth = stack.pop()\n            max_d = max(max_d, depth)\n            if node.left:\n                stack.append((node.left, depth + 1))\n            if node.right:\n                stack.append((node.right, depth + 1))\n        return max_d\n",
        "filename": "Max_Depth.py"
      },
      {
        "number": 105,
        "title": "Construct Tree from Preorder Inorder",
        "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
        "intuition": "The first element of preorder is the root. Find that root's index in inorder \u2014 everything to the left is the left subtree, everything to the right is the right subtree. Recurse with the appropriate slices. Use a hash map for O(1) index lookups in inorder.",
        "time": "O(n)",
        "space": "O(n)",
        "code": "\"\"\"\n105. Construct Binary Tree from Preorder and Inorder Traversal\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\n\nGiven preorder and inorder traversal arrays, reconstruct the tree.\n\nKey Intuition:\n    The first element of preorder is the root. Find that root's index\n    in inorder \u2014 everything to the left is the left subtree, everything\n    to the right is the right subtree. Recurse with the appropriate slices.\n    Use a hash map for O(1) index lookups in inorder.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import Optional, List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Recursive with index map\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def buildTree(\n        self, preorder: List[int], inorder: List[int]\n    ) -> Optional[TreeNode]:\n        inorder_idx = {val: i for i, val in enumerate(inorder)}\n        self.pre_idx = 0\n\n        def build(lo, hi):\n            if lo > hi:\n                return None\n            root_val = preorder[self.pre_idx]\n            self.pre_idx += 1\n            root = TreeNode(root_val)\n            mid = inorder_idx[root_val]\n            root.left = build(lo, mid - 1)\n            root.right = build(mid + 1, hi)\n            return root\n\n        return build(0, len(inorder) - 1)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Array slicing (cleaner but O(n\u00b2) due to slicing)\n# Time O(n\u00b2) \u00b7 Space O(n\u00b2)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSlice:\n    def buildTree(\n        self, preorder: List[int], inorder: List[int]\n    ) -> Optional[TreeNode]:\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1:], inorder[mid + 1:])\n        return root\n",
        "filename": "Construct_Tree_from_Preorder_Inorder.py"
      },
      {
        "number": 124,
        "title": "Binary Tree Max Path Sum",
        "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
        "intuition": "At each node, compute the max \"gain\" it can contribute to its parent (single branch). Meanwhile, update a global max considering the path that *passes through* this node (left gain + node + right gain). Gains are clamped to 0 (ignore negative branches).",
        "time": "O(n)",
        "space": "O(h)",
        "code": "\"\"\"\n124. Binary Tree Maximum Path Sum\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/\n\nA path is any sequence of nodes connected by edges. Find the maximum\npath sum (path doesn't need to go through the root).\n\nKey Intuition:\n    At each node, compute the max \"gain\" it can contribute to its parent\n    (single branch). Meanwhile, update a global max considering the path\n    that *passes through* this node (left gain + node + right gain).\n    Gains are clamped to 0 (ignore negative branches).\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(h)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Post\u2011order DFS\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        self.result = float('-inf')\n\n        def dfs(node):\n            if not node:\n                return 0\n            left_gain = max(dfs(node.left), 0)   # ignore negative\n            right_gain = max(dfs(node.right), 0)\n\n            # Path that passes through this node\n            self.result = max(self.result, node.val + left_gain + right_gain)\n\n            # Return max gain this node can contribute to its parent\n            return node.val + max(left_gain, right_gain)\n\n        dfs(root)\n        return self.result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Same logic, iterative post\u2011order with stack\n# Time O(n) \u00b7 Space O(n)\n# (Rarely needed in interviews \u2014 recursive version is cleaner)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionIterative:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        result = float('-inf')\n        gains = {}   # node -> max single-branch gain\n\n        stack = [(root, False)]\n        while stack:\n            node, visited = stack.pop()\n            if not node:\n                continue\n            if visited:\n                left_gain = max(gains.get(node.left, 0), 0)\n                right_gain = max(gains.get(node.right, 0), 0)\n                result = max(result, node.val + left_gain + right_gain)\n                gains[node] = node.val + max(left_gain, right_gain)\n            else:\n                stack.append((node, True))\n                stack.append((node.right, False))\n                stack.append((node.left, False))\n\n        return result\n",
        "filename": "Binary_Tree_Max_Path_Sum.py"
      },
      {
        "number": 226,
        "title": "Invert Binary Tree",
        "url": "https://leetcode.com/problems/invert-binary-tree/",
        "intuition": "At every node, swap its left and right children, then recurse. Base case: null node, just return None.",
        "time": "O(n)",
        "space": "O(h)  \u2014 h = height (O(n) worst case, O(log n) balanced)",
        "code": "\"\"\"\n226. Invert Binary Tree\nhttps://leetcode.com/problems/invert-binary-tree/\n\nGiven the root of a binary tree, invert it (mirror) and return the root.\n\nKey Intuition:\n    At every node, swap its left and right children, then recurse.\n    Base case: null node, just return None.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(h)  \u2014 h = height (O(n) worst case, O(log n) balanced)\n\"\"\"\n\nfrom typing import Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: DFS recursive\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: BFS iterative\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBFS:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            node.left, node.right = node.right, node.left\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        return root\n",
        "filename": "Invert_Binary_Tree.py"
      },
      {
        "number": 230,
        "title": "Kth Smallest Element in BST",
        "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
        "intuition": "In\u2011order traversal of a BST yields elements in sorted order. Just count to k during the traversal.",
        "time": "O(h + k)",
        "space": "O(h)",
        "code": "\"\"\"\n230. Kth Smallest Element in a BST\nhttps://leetcode.com/problems/kth-smallest-element-in-a-bst/\n\nGiven the root of a BST and an integer k, return the k\u2011th smallest value.\n\nKey Intuition:\n    In\u2011order traversal of a BST yields elements in sorted order.\n    Just count to k during the traversal.\n\nComplexity (Optimal):\n    Time:  O(h + k)\n    Space: O(h)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Iterative in\u2011order traversal\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        cur = root\n\n        while cur or stack:\n            # Go as far left as possible\n            while cur:\n                stack.append(cur)\n                cur = cur.left\n\n            cur = stack.pop()\n            k -= 1\n            if k == 0:\n                return cur.val\n\n            cur = cur.right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Recursive in\u2011order (collect all, pick k\u2011th)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionRecursive:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        result = []\n\n        def inorder(node):\n            if not node or len(result) >= k:\n                return\n            inorder(node.left)\n            result.append(node.val)\n            inorder(node.right)\n\n        inorder(root)\n        return result[k - 1]\n",
        "filename": "Kth_Smallest_Element_in_BST.py"
      },
      {
        "number": 235,
        "title": "LCA of BST",
        "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
        "intuition": "Exploit BST ordering: if both nodes are smaller, go left; if both are larger, go right. The first node where they *split* (one on each side or one equals current) is the LCA.",
        "time": "O(h)  \u2014 h = height of tree",
        "space": "O(1)  \u2014 iterative",
        "code": "\"\"\"\n235. Lowest Common Ancestor of a Binary Search Tree\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\n\nGiven a BST, find the lowest common ancestor of two given nodes.\n\nKey Intuition:\n    Exploit BST ordering: if both nodes are smaller, go left; if both\n    are larger, go right. The first node where they *split* (one on\n    each side or one equals current) is the LCA.\n\nComplexity (Optimal):\n    Time:  O(h)  \u2014 h = height of tree\n    Space: O(1)  \u2014 iterative\n\"\"\"\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Iterative\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: TreeNode, p: TreeNode, q: TreeNode\n    ) -> TreeNode:\n        cur = root\n        while cur:\n            if p.val < cur.val and q.val < cur.val:\n                cur = cur.left\n            elif p.val > cur.val and q.val > cur.val:\n                cur = cur.right\n            else:\n                return cur\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Recursive\n# Time O(h) \u00b7 Space O(h)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionRecursive:\n    def lowestCommonAncestor(\n        self, root: TreeNode, p: TreeNode, q: TreeNode\n    ) -> TreeNode:\n        if p.val < root.val and q.val < root.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        if p.val > root.val and q.val > root.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        return root\n",
        "filename": "LCA_of_BST.py"
      },
      {
        "number": 297,
        "title": "Serialize Deserialize Binary Tree",
        "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
        "intuition": "Use pre\u2011order DFS. Represent null nodes with a sentinel (e.g. \"N\"). On deserialization, consume tokens in the same pre\u2011order sequence, using nulls to know when a subtree is complete.",
        "time": "O(n)  \u2014 both serialize & deserialize",
        "space": "O(n)",
        "code": "\"\"\"\n297. Serialize and Deserialize Binary Tree\nhttps://leetcode.com/problems/serialize-and-deserialize-binary-tree/\n\nDesign an algorithm to serialize a binary tree to a string and\ndeserialize it back.\n\nKey Intuition:\n    Use pre\u2011order DFS. Represent null nodes with a sentinel (e.g. \"N\").\n    On deserialization, consume tokens in the same pre\u2011order sequence,\n    using nulls to know when a subtree is complete.\n\nComplexity:\n    Time:  O(n)  \u2014 both serialize & deserialize\n    Space: O(n)\n\"\"\"\n\nfrom typing import Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Pre\u2011order DFS\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Codec:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        result = []\n\n        def dfs(node):\n            if not node:\n                result.append(\"N\")\n                return\n            result.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(result)\n\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        tokens = iter(data.split(\",\"))\n\n        def dfs():\n            val = next(tokens)\n            if val == \"N\":\n                return None\n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: BFS (level\u2011order) serialization\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass CodecBFS:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        if not root:\n            return \"\"\n        result = []\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append(\"N\")\n        return \",\".join(result)\n\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        if not data:\n            return None\n        tokens = data.split(\",\")\n        root = TreeNode(int(tokens[0]))\n        queue = deque([root])\n        i = 1\n        while queue:\n            node = queue.popleft()\n            if tokens[i] != \"N\":\n                node.left = TreeNode(int(tokens[i]))\n                queue.append(node.left)\n            i += 1\n            if tokens[i] != \"N\":\n                node.right = TreeNode(int(tokens[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n",
        "filename": "Serialize_Deserialize_Binary_Tree.py"
      },
      {
        "number": 572,
        "title": "Subtree of Another Tree",
        "url": "https://leetcode.com/problems/subtree-of-another-tree/",
        "intuition": "At every node in root, check whether the subtree rooted there is identical to subRoot (using isSameTree). One match is enough.",
        "time": "O(m \u00b7 n)  \u2014 m = nodes in root, n = nodes in subRoot",
        "space": "O(h)      \u2014 recursion depth",
        "code": "\"\"\"\n572. Subtree of Another Tree\nhttps://leetcode.com/problems/subtree-of-another-tree/\n\nGiven roots of trees root and subRoot, return true if subRoot is a\nsubtree of root.\n\nKey Intuition:\n    At every node in root, check whether the subtree rooted there is\n    identical to subRoot (using isSameTree). One match is enough.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n)  \u2014 m = nodes in root, n = nodes in subRoot\n    Space: O(h)      \u2014 recursion depth\n\"\"\"\n\nfrom typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Recursive check at every node\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not subRoot:\n            return True\n        if not root:\n            return False\n        if self._isSame(root, subRoot):\n            return True\n        return (self.isSubtree(root.left, subRoot) or\n                self.isSubtree(root.right, subRoot))\n\n    def _isSame(self, s: Optional[TreeNode], t: Optional[TreeNode]) -> bool:\n        if not s and not t:\n            return True\n        if not s or not t or s.val != t.val:\n            return False\n        return self._isSame(s.left, t.left) and self._isSame(s.right, t.right)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Serialize both trees and use string matching\n# Time O(m + n) with KMP \u2014 but O(m \u00b7 n) with naive find\n# Space O(m + n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSerialize:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        def serialize(node):\n            if not node:\n                return \"#\"\n            # Use delimiters to avoid false substring matches\n            return f\",{node.val},{serialize(node.left)},{serialize(node.right)}\"\n\n        return serialize(subRoot) in serialize(root)\n",
        "filename": "Subtree_of_Another_Tree.py"
      }
    ]
  },
  {
    "name": "Tries",
    "icon": "text_fields",
    "problems": [
      {
        "number": 208,
        "title": "Implement Trie",
        "url": "https://leetcode.com/problems/implement-trie-prefix-tree/",
        "intuition": "Each node is a dictionary of children keyed by character, plus a boolean marking end\u2011of\u2011word. Traversal follows one character at a time \u2014 O(L) per operation where L = word length.",
        "time": "",
        "space": "",
        "code": "\"\"\"\n208. Implement Trie (Prefix Tree)\nhttps://leetcode.com/problems/implement-trie-prefix-tree/\n\nImplement a trie with insert, search, and startsWith.\n\nKey Intuition:\n    Each node is a dictionary of children keyed by character, plus a\n    boolean marking end\u2011of\u2011word. Traversal follows one character at a\n    time \u2014 O(L) per operation where L = word length.\n\nComplexity:\n    insert:      Time O(L) \u00b7 Space O(L)\n    search:      Time O(L) \u00b7 Space O(1)\n    startsWith:  Time O(L) \u00b7 Space O(1)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Dict\u2011of\u2011dicts Trie\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self._find(word)\n        return node is not None and node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        return self._find(prefix) is not None\n\n    def _find(self, prefix: str) -> TrieNode:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return None\n            node = node.children[ch]\n        return node\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Using defaultdict for auto\u2011vivification\n# Same complexity, slightly more concise\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfrom collections import defaultdict\n\n\nclass TrieDefaultDict:\n    def __init__(self):\n        # Nested defaultdict factory\n        self.root = {}\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.setdefault(ch, {})\n        node['#'] = True  # end marker\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node:\n                return False\n            node = node[ch]\n        return '#' in node\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node:\n                return False\n            node = node[ch]\n        return True\n",
        "filename": "Implement_Trie.py"
      },
      {
        "number": 211,
        "title": "Design Add Search Words",
        "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/",
        "intuition": "Build a standard Trie for addWord. For search, when a '.' is encountered, branch out and try all children recursively. Only one path needs to succeed.",
        "time": "",
        "space": "",
        "code": "\"\"\"\n211. Design Add and Search Words Data Structure\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/\n\nDesign a data structure that supports addWord and search. The search\nword can contain '.' which matches any letter.\n\nKey Intuition:\n    Build a standard Trie for addWord. For search, when a '.' is\n    encountered, branch out and try all children recursively. Only\n    one path needs to succeed.\n\nComplexity:\n    addWord: Time O(L) \u00b7 Space O(L)\n    search:  Time O(26^L) worst case with all dots \u00b7 Space O(L) stack\n             Typically much faster with real words.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Trie with DFS wildcard handling\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(index, node):\n            if index == len(word):\n                return node.is_end\n\n            ch = word[index]\n            if ch == '.':\n                # Try every child\n                for child in node.children.values():\n                    if dfs(index + 1, child):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(index + 1, node.children[ch])\n\n        return dfs(0, self.root)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Bucket by word length + regex (simpler but slower)\n# addWord O(1) \u00b7 search O(n\u00b7L) where n = words of that length\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfrom collections import defaultdict\n\n\nclass WordDictionaryBrute:\n    def __init__(self):\n        self.words = defaultdict(list)\n\n    def addWord(self, word: str) -> None:\n        self.words[len(word)].append(word)\n\n    def search(self, word: str) -> bool:\n        for candidate in self.words[len(word)]:\n            if all(w == '.' or w == c for w, c in zip(word, candidate)):\n                return True\n        return False\n",
        "filename": "Design_Add_Search_Words.py"
      },
      {
        "number": 212,
        "title": "Word Search II",
        "url": "https://leetcode.com/problems/word-search-ii/",
        "intuition": "Build a Trie from the word list. DFS from every cell; as you walk the board, walk the Trie simultaneously. Prune branches where the Trie has no continuation. Remove found words to avoid duplicates and to prune dead branches.",
        "time": "O(m \u00b7 n \u00b7 4^L)  \u2014 L = max word length (pruning makes it much faster)",
        "space": "O(W \u00b7 L)        \u2014 W = number of words in the trie",
        "code": "\"\"\"\n212. Word Search II\nhttps://leetcode.com/problems/word-search-ii/\n\nGiven an m \u00d7 n board and a list of words, return all words that can be\nformed by sequentially adjacent cells (no cell reused per word).\n\nKey Intuition:\n    Build a Trie from the word list. DFS from every cell; as you walk\n    the board, walk the Trie simultaneously. Prune branches where the\n    Trie has no continuation. Remove found words to avoid duplicates\n    and to prune dead branches.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n \u00b7 4^L)  \u2014 L = max word length (pruning makes it much faster)\n    Space: O(W \u00b7 L)        \u2014 W = number of words in the trie\n\"\"\"\n\nfrom typing import List\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None  # stores complete word at leaf\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Trie + Backtracking with pruning\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n\n        # Build trie\n        for word in words:\n            node = root\n            for ch in word:\n                if ch not in node.children:\n                    node.children[ch] = TrieNode()\n                node = node.children[ch]\n            node.word = word\n\n        rows, cols = len(board), len(board[0])\n        result = []\n\n        def dfs(r, c, node):\n            ch = board[r][c]\n            if ch not in node.children:\n                return\n            child = node.children[ch]\n\n            if child.word:\n                result.append(child.word)\n                child.word = None  # de-duplicate\n\n            # Mark visited\n            board[r][c] = '#'\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '#':\n                    dfs(nr, nc, child)\n            board[r][c] = ch  # restore\n\n            # Prune: remove leaf nodes with no children\n            if not child.children:\n                del node.children[ch]\n\n        for r in range(rows):\n            for c in range(cols):\n                dfs(r, c, root)\n\n        return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Per\u2011word backtracking (simpler but slower)\n# Time O(W \u00b7 m \u00b7 n \u00b7 4^L) \u2014 W words each searched independently\n# Not recommended for large inputs.\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBrute:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        rows, cols = len(board), len(board[0])\n        result = []\n\n        def exist(word):\n            def dfs(r, c, idx):\n                if idx == len(word):\n                    return True\n                if (r < 0 or r >= rows or c < 0 or c >= cols or\n                        board[r][c] != word[idx]):\n                    return False\n                tmp = board[r][c]\n                board[r][c] = '#'\n                found = any(dfs(r + dr, c + dc, idx + 1)\n                            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)])\n                board[r][c] = tmp\n                return found\n\n            for r in range(rows):\n                for c in range(cols):\n                    if dfs(r, c, 0):\n                        return True\n            return False\n\n        for word in words:\n            if exist(word):\n                result.append(word)\n        return result\n",
        "filename": "Word_Search_II.py"
      }
    ]
  },
  {
    "name": "Heap",
    "icon": "filter_list",
    "problems": [
      {
        "number": 295,
        "title": "Find Median from Data Stream",
        "url": "https://leetcode.com/problems/find-median-from-data-stream/",
        "intuition": "Maintain two heaps: a max\u2011heap for the smaller half and a min\u2011heap for the larger half. Keep them balanced (sizes differ by at most 1). The median is the top of the larger heap \u2014 or the average of both tops.",
        "time": "",
        "space": "O(n)",
        "code": "\"\"\"\n295. Find Median from Data Stream\nhttps://leetcode.com/problems/find-median-from-data-stream/\n\nDesign a data structure that supports addNum and findMedian.\n\nKey Intuition:\n    Maintain two heaps: a max\u2011heap for the smaller half and a min\u2011heap\n    for the larger half. Keep them balanced (sizes differ by at most 1).\n    The median is the top of the larger heap \u2014 or the average of both tops.\n\nComplexity:\n    addNum:     Time O(log n)\n    findMedian: Time O(1)\n    Space: O(n)\n\"\"\"\n\nimport heapq\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Two heaps (max\u2011heap + min\u2011heap)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass MedianFinder:\n    def __init__(self):\n        # max\u2011heap (invert values) for smaller half\n        self.lo = []   # max-heap (negate values)\n        # min\u2011heap for larger half\n        self.hi = []   # min-heap\n\n    def addNum(self, num: int) -> None:\n        # Always add to max\u2011heap first\n        heapq.heappush(self.lo, -num)\n        # Move top of lo to hi to maintain ordering\n        heapq.heappush(self.hi, -heapq.heappop(self.lo))\n        # Balance: lo should have >= hi elements\n        if len(self.hi) > len(self.lo):\n            heapq.heappush(self.lo, -heapq.heappop(self.hi))\n\n    def findMedian(self) -> float:\n        if len(self.lo) > len(self.hi):\n            return -self.lo[0]\n        return (-self.lo[0] + self.hi[0]) / 2.0\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: SortedList (from sortedcontainers)\n# addNum O(log n) \u00b7 findMedian O(1)\n# Requires: pip install sortedcontainers\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# from sortedcontainers import SortedList\n#\n# class MedianFinderSorted:\n#     def __init__(self):\n#         self.data = SortedList()\n#\n#     def addNum(self, num: int) -> None:\n#         self.data.add(num)\n#\n#     def findMedian(self) -> float:\n#         n = len(self.data)\n#         if n % 2 == 1:\n#             return self.data[n // 2]\n#         return (self.data[n // 2 - 1] + self.data[n // 2]) / 2.0\n",
        "filename": "Find_Median_from_Data_Stream.py"
      }
    ]
  },
  {
    "name": "Backtracking",
    "icon": "undo",
    "problems": [
      {
        "number": 39,
        "title": "Combination Sum",
        "url": "https://leetcode.com/problems/combination-sum/",
        "intuition": "Classic backtracking: at each step, either include the current candidate again (unlimited reuse) or move to the next one. Pruning: skip when remaining target < 0.",
        "time": "O(n^(T/M))  \u2014 T = target, M = min candidate",
        "space": "O(T/M)      \u2014 max recursion depth",
        "code": "\"\"\"\n39. Combination Sum\nhttps://leetcode.com/problems/combination-sum/\n\nGiven an array of distinct integers candidates and a target, return all\nunique combinations where the chosen numbers sum to target. The same\nnumber may be used unlimited times.\n\nKey Intuition:\n    Classic backtracking: at each step, either include the current\n    candidate again (unlimited reuse) or move to the next one.\n    Pruning: skip when remaining target < 0.\n\nComplexity:\n    Time:  O(n^(T/M))  \u2014 T = target, M = min candidate\n    Space: O(T/M)      \u2014 max recursion depth\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Backtracking\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def combinationSum(\n        self, candidates: List[int], target: int\n    ) -> List[List[int]]:\n        result = []\n\n        def backtrack(start, combo, remaining):\n            if remaining == 0:\n                result.append(combo[:])\n                return\n            if remaining < 0:\n                return\n            for i in range(start, len(candidates)):\n                combo.append(candidates[i])\n                # Pass i (not i+1) because we can reuse the same element\n                backtrack(i, combo, remaining - candidates[i])\n                combo.pop()\n\n        backtrack(0, [], target)\n        return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Backtracking with sorting + early termination\n# Same time complexity, but prunes faster in practice.\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSorted:\n    def combinationSum(\n        self, candidates: List[int], target: int\n    ) -> List[List[int]]:\n        candidates.sort()\n        result = []\n\n        def backtrack(start, combo, remaining):\n            if remaining == 0:\n                result.append(combo[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remaining:\n                    break  # early termination\n                combo.append(candidates[i])\n                backtrack(i, combo, remaining - candidates[i])\n                combo.pop()\n\n        backtrack(0, [], target)\n        return result\n",
        "filename": "Combination_Sum.py"
      },
      {
        "number": 79,
        "title": "Word Search",
        "url": "https://leetcode.com/problems/word-search/",
        "intuition": "DFS/backtracking from every cell. At each step, mark the cell as visited, explore 4 directions, then unmark (backtrack). Match one character at a time; return True as soon as the full word is matched.",
        "time": "O(m \u00b7 n \u00b7 4^L)  \u2014 L = word length",
        "space": "O(L)             \u2014 recursion depth",
        "code": "\"\"\"\n79. Word Search\nhttps://leetcode.com/problems/word-search/\n\nGiven an m \u00d7 n board and a word, return true if the word exists in the\ngrid by following adjacent cells (no cell reused).\n\nKey Intuition:\n    DFS/backtracking from every cell. At each step, mark the cell as\n    visited, explore 4 directions, then unmark (backtrack). Match one\n    character at a time; return True as soon as the full word is matched.\n\nComplexity:\n    Time:  O(m \u00b7 n \u00b7 4^L)  \u2014 L = word length\n    Space: O(L)             \u2014 recursion depth\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Backtracking DFS\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        rows, cols = len(board), len(board[0])\n\n        def dfs(r, c, idx):\n            if idx == len(word):\n                return True\n            if (r < 0 or r >= rows or c < 0 or c >= cols or\n                    board[r][c] != word[idx]):\n                return False\n\n            # Mark visited\n            tmp = board[r][c]\n            board[r][c] = '#'\n\n            found = (dfs(r + 1, c, idx + 1) or\n                     dfs(r - 1, c, idx + 1) or\n                     dfs(r, c + 1, idx + 1) or\n                     dfs(r, c - 1, idx + 1))\n\n            board[r][c] = tmp  # backtrack\n            return found\n\n        for r in range(rows):\n            for c in range(cols):\n                if dfs(r, c, 0):\n                    return True\n        return False\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimization tip: Count character frequencies first.\n# If the word's first character is rarer than the last,\n# search the reversed word to prune faster.\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfrom collections import Counter\n\n\nclass SolutionOptimized:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        rows, cols = len(board), len(board[0])\n        board_count = Counter(ch for row in board for ch in row)\n        word_count = Counter(word)\n\n        # Check if board has enough characters\n        for ch, cnt in word_count.items():\n            if board_count[ch] < cnt:\n                return False\n\n        # Reverse word if first char is more common than last\n        if board_count[word[0]] > board_count[word[-1]]:\n            word = word[::-1]\n\n        def dfs(r, c, idx):\n            if idx == len(word):\n                return True\n            if (r < 0 or r >= rows or c < 0 or c >= cols or\n                    board[r][c] != word[idx]):\n                return False\n            tmp = board[r][c]\n            board[r][c] = '#'\n            found = (dfs(r + 1, c, idx + 1) or dfs(r - 1, c, idx + 1) or\n                     dfs(r, c + 1, idx + 1) or dfs(r, c - 1, idx + 1))\n            board[r][c] = tmp\n            return found\n\n        for r in range(rows):\n            for c in range(cols):\n                if dfs(r, c, 0):\n                    return True\n        return False\n",
        "filename": "Word_Search.py"
      }
    ]
  },
  {
    "name": "Graphs",
    "icon": "hub",
    "problems": [
      {
        "number": 133,
        "title": "Clone Graph",
        "url": "https://leetcode.com/problems/clone-graph/",
        "intuition": "Use a hash map {original_node: cloned_node} to avoid revisiting and to handle cycles. BFS or DFS \u2014 whenever you encounter a neighbor, either clone it (if new) or reuse the existing clone.",
        "time": "O(V + E)",
        "space": "O(V)",
        "code": "\"\"\"\n133. Clone Graph\nhttps://leetcode.com/problems/clone-graph/\n\nGiven a reference to a node in a connected undirected graph, return a\ndeep copy (clone) of the graph.\n\nKey Intuition:\n    Use a hash map {original_node: cloned_node} to avoid revisiting\n    and to handle cycles. BFS or DFS \u2014 whenever you encounter a neighbor,\n    either clone it (if new) or reuse the existing clone.\n\nComplexity (Optimal):\n    Time:  O(V + E)\n    Space: O(V)\n\"\"\"\n\nfrom typing import Optional\nfrom collections import deque\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: BFS\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def cloneGraph(self, node: Optional[Node]) -> Optional[Node]:\n        if not node:\n            return None\n\n        clones = {node: Node(node.val)}\n        queue = deque([node])\n\n        while queue:\n            cur = queue.popleft()\n            for neighbor in cur.neighbors:\n                if neighbor not in clones:\n                    clones[neighbor] = Node(neighbor.val)\n                    queue.append(neighbor)\n                clones[cur].neighbors.append(clones[neighbor])\n\n        return clones[node]\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DFS recursive\n# Time O(V + E) \u00b7 Space O(V)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDFS:\n    def cloneGraph(self, node: Optional[Node]) -> Optional[Node]:\n        if not node:\n            return None\n\n        clones = {}\n\n        def dfs(cur):\n            if cur in clones:\n                return clones[cur]\n            clone = Node(cur.val)\n            clones[cur] = clone\n            for neighbor in cur.neighbors:\n                clone.neighbors.append(dfs(neighbor))\n            return clone\n\n        return dfs(node)\n",
        "filename": "Clone_Graph.py"
      },
      {
        "number": 200,
        "title": "Number of Islands",
        "url": "https://leetcode.com/problems/number-of-islands/",
        "intuition": "Each connected component of '1's is one island. BFS/DFS from every unvisited '1', marking cells as visited (sink them to '0'). Each new traversal start = one more island.",
        "time": "O(m \u00b7 n)",
        "space": "O(m \u00b7 n) worst case for BFS queue / DFS stack",
        "code": "\"\"\"\n200. Number of Islands\nhttps://leetcode.com/problems/number-of-islands/\n\nGiven an m \u00d7 n 2D grid of '1's (land) and '0's (water), return the\nnumber of islands.\n\nKey Intuition:\n    Each connected component of '1's is one island. BFS/DFS from every\n    unvisited '1', marking cells as visited (sink them to '0'). Each\n    new traversal start = one more island.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n)\n    Space: O(m \u00b7 n) worst case for BFS queue / DFS stack\n\"\"\"\n\nfrom typing import List\nfrom collections import deque\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: BFS\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid:\n            return 0\n        rows, cols = len(grid), len(grid[0])\n        count = 0\n\n        def bfs(r, c):\n            queue = deque([(r, c)])\n            grid[r][c] = '0'\n            while queue:\n                row, col = queue.popleft()\n                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nr, nc = row + dr, col + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':\n                        grid[nr][nc] = '0'\n                        queue.append((nr, nc))\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == '1':\n                    bfs(r, c)\n                    count += 1\n        return count\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DFS recursive\n# Time O(m \u00b7 n) \u00b7 Space O(m \u00b7 n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDFS:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid:\n            return 0\n        rows, cols = len(grid), len(grid[0])\n        count = 0\n\n        def dfs(r, c):\n            if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':\n                return\n            grid[r][c] = '0'\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == '1':\n                    dfs(r, c)\n                    count += 1\n        return count\n",
        "filename": "Number_of_Islands.py"
      },
      {
        "number": 207,
        "title": "Course Schedule",
        "url": "https://leetcode.com/problems/course-schedule/",
        "intuition": "This is cycle detection in a directed graph. BFS topological sort (Kahn's algorithm): start from nodes with in\u2011degree 0; if you can process all nodes, there's no cycle.",
        "time": "O(V + E)",
        "space": "O(V + E)",
        "code": "\"\"\"\n207. Course Schedule\nhttps://leetcode.com/problems/course-schedule/\n\nThere are numCourses courses (0 to numCourses-1) and prerequisites.\nReturn true if you can finish all courses (no cycle in the DAG).\n\nKey Intuition:\n    This is cycle detection in a directed graph. BFS topological sort\n    (Kahn's algorithm): start from nodes with in\u2011degree 0; if you can\n    process all nodes, there's no cycle.\n\nComplexity (Optimal):\n    Time:  O(V + E)\n    Space: O(V + E)\n\"\"\"\n\nfrom typing import List\nfrom collections import deque, defaultdict\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: BFS topological sort (Kahn's algorithm)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def canFinish(\n        self, numCourses: int, prerequisites: List[List[int]]\n    ) -> bool:\n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            in_degree[course] += 1\n\n        queue = deque(i for i in range(numCourses) if in_degree[i] == 0)\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DFS cycle detection\n# Time O(V + E) \u00b7 Space O(V + E)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDFS:\n    def canFinish(\n        self, numCourses: int, prerequisites: List[List[int]]\n    ) -> bool:\n        graph = defaultdict(list)\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n\n        # 0 = unvisited, 1 = in current path, 2 = fully processed\n        state = [0] * numCourses\n\n        def has_cycle(node):\n            if state[node] == 1:\n                return True   # back edge \u2192 cycle\n            if state[node] == 2:\n                return False  # already processed\n            state[node] = 1\n            for neighbor in graph[node]:\n                if has_cycle(neighbor):\n                    return True\n            state[node] = 2\n            return False\n\n        return not any(has_cycle(i) for i in range(numCourses))\n",
        "filename": "Course_Schedule.py"
      },
      {
        "number": 261,
        "title": "Graph Valid Tree",
        "url": "https://leetcode.com/problems/graph-valid-tree/",
        "intuition": "A valid tree must satisfy two conditions: 1. Exactly n-1 edges (otherwise cycle or disconnected). 2. All nodes are connected (single component). Union\u2011Find checks both: n-1 edges + no cycle during unions.",
        "time": "O(E \u00b7 \u03b1(n)) \u2248 O(E)",
        "space": "O(n)",
        "code": "\"\"\"\n261. Graph Valid Tree (Premium)\nhttps://leetcode.com/problems/graph-valid-tree/\n\nGiven n nodes (0 to n-1) and a list of undirected edges, determine if\nthese edges form a valid tree.\n\nKey Intuition:\n    A valid tree must satisfy two conditions:\n    1. Exactly n-1 edges (otherwise cycle or disconnected).\n    2. All nodes are connected (single component).\n    Union\u2011Find checks both: n-1 edges + no cycle during unions.\n\nComplexity (Optimal):\n    Time:  O(E \u00b7 \u03b1(n)) \u2248 O(E)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\nfrom collections import defaultdict\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Union\u2011Find\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if len(edges) != n - 1:\n            return False  # quick check\n\n        parent = list(range(n))\n        rank = [0] * n\n\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        def union(a, b):\n            ra, rb = find(a), find(b)\n            if ra == rb:\n                return False  # cycle\n            if rank[ra] < rank[rb]:\n                ra, rb = rb, ra\n            parent[rb] = ra\n            if rank[ra] == rank[rb]:\n                rank[ra] += 1\n            return True\n\n        return all(union(a, b) for a, b in edges)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DFS \u2014 check connectivity and no cycle\n# Time O(V + E) \u00b7 Space O(V + E)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDFS:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if len(edges) != n - 1:\n            return False\n\n        graph = defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        visited = set()\n\n        def dfs(node):\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    dfs(neighbor)\n\n        dfs(0)\n        return len(visited) == n\n",
        "filename": "Graph_Valid_Tree.py"
      },
      {
        "number": 323,
        "title": "Number of Connected Components",
        "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
        "intuition": "Classic Union\u2011Find: start with n components. For each edge, union the two nodes \u2014 each successful union reduces the component count by 1.",
        "time": "O(E \u00b7 \u03b1(n)) \u2248 O(E)",
        "space": "O(n)",
        "code": "\"\"\"\n323. Number of Connected Components in an Undirected Graph (Premium)\nhttps://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/\n\nGiven n nodes (0 to n-1) and a list of edges, return the number of\nconnected components.\n\nKey Intuition:\n    Classic Union\u2011Find: start with n components. For each edge, union\n    the two nodes \u2014 each successful union reduces the component count by 1.\n\nComplexity (Optimal \u2013 Union\u2011Find):\n    Time:  O(E \u00b7 \u03b1(n)) \u2248 O(E)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\nfrom collections import defaultdict, deque\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Union\u2011Find (Disjoint Set Union)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        parent = list(range(n))\n        rank = [0] * n\n\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]  # path compression\n                x = parent[x]\n            return x\n\n        def union(a, b):\n            ra, rb = find(a), find(b)\n            if ra == rb:\n                return False\n            if rank[ra] < rank[rb]:\n                ra, rb = rb, ra\n            parent[rb] = ra\n            if rank[ra] == rank[rb]:\n                rank[ra] += 1\n            return True\n\n        components = n\n        for a, b in edges:\n            if union(a, b):\n                components -= 1\n        return components\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: BFS/DFS\n# Time O(V + E) \u00b7 Space O(V + E)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBFS:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        visited = set()\n        count = 0\n\n        for node in range(n):\n            if node not in visited:\n                count += 1\n                queue = deque([node])\n                visited.add(node)\n                while queue:\n                    cur = queue.popleft()\n                    for neighbor in graph[cur]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n        return count\n",
        "filename": "Number_of_Connected_Components.py"
      },
      {
        "number": 417,
        "title": "Pacific Atlantic Water Flow",
        "url": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
        "intuition": "Instead of flowing *from* every cell (expensive), start from the ocean borders and BFS/DFS *inward* (reverse flow: go to cells \u2265 current). Cells reachable from both oceans are the answer.",
        "time": "O(m \u00b7 n)",
        "space": "O(m \u00b7 n)",
        "code": "\"\"\"\n417. Pacific Atlantic Water Flow\nhttps://leetcode.com/problems/pacific-atlantic-water-flow/\n\nGiven an m \u00d7 n island height map, return all cells from which water can\nflow to both the Pacific and Atlantic oceans.\n\nKey Intuition:\n    Instead of flowing *from* every cell (expensive), start from the ocean\n    borders and BFS/DFS *inward* (reverse flow: go to cells \u2265 current).\n    Cells reachable from both oceans are the answer.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n)\n    Space: O(m \u00b7 n)\n\"\"\"\n\nfrom typing import List\nfrom collections import deque\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Reverse BFS from both oceans\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        if not heights:\n            return []\n        rows, cols = len(heights), len(heights[0])\n        pacific = set()\n        atlantic = set()\n\n        def bfs(starts, reachable):\n            queue = deque(starts)\n            reachable.update(starts)\n            while queue:\n                r, c = queue.popleft()\n                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nr, nc = r + dr, c + dc\n                    if (0 <= nr < rows and 0 <= nc < cols and\n                            (nr, nc) not in reachable and\n                            heights[nr][nc] >= heights[r][c]):\n                        reachable.add((nr, nc))\n                        queue.append((nr, nc))\n\n        # Pacific: top row + left col\n        pac_starts = ([(0, c) for c in range(cols)] +\n                      [(r, 0) for r in range(rows)])\n        # Atlantic: bottom row + right col\n        atl_starts = ([(rows - 1, c) for c in range(cols)] +\n                      [(r, cols - 1) for r in range(rows)])\n\n        bfs(pac_starts, pacific)\n        bfs(atl_starts, atlantic)\n\n        return [[r, c] for r, c in pacific & atlantic]\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DFS version\n# Time O(m \u00b7 n) \u00b7 Space O(m \u00b7 n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDFS:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        if not heights:\n            return []\n        rows, cols = len(heights), len(heights[0])\n        pacific = set()\n        atlantic = set()\n\n        def dfs(r, c, reachable, prev_height):\n            if ((r, c) in reachable or r < 0 or r >= rows or\n                    c < 0 or c >= cols or heights[r][c] < prev_height):\n                return\n            reachable.add((r, c))\n            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                dfs(r + dr, c + dc, reachable, heights[r][c])\n\n        for c in range(cols):\n            dfs(0, c, pacific, heights[0][c])\n            dfs(rows - 1, c, atlantic, heights[rows - 1][c])\n        for r in range(rows):\n            dfs(r, 0, pacific, heights[r][0])\n            dfs(r, cols - 1, atlantic, heights[r][cols - 1])\n\n        return [[r, c] for r, c in pacific & atlantic]\n",
        "filename": "Pacific_Atlantic_Water_Flow.py"
      }
    ]
  },
  {
    "name": "Advanced Graphs",
    "icon": "polyline",
    "problems": [
      {
        "number": 269,
        "title": "Alien Dictionary",
        "url": "https://leetcode.com/problems/alien-dictionary/",
        "intuition": "Compare adjacent words to extract ordering constraints (edges in a directed graph). Then topological sort (BFS \u2014 Kahn's) to produce the character order. If a cycle exists, the order is invalid.",
        "time": "O(C)  \u2014 C = total characters across all words",
        "space": "O(1)  \u2014 at most 26 nodes/edges (bounded alphabet)",
        "code": "\"\"\"\n269. Alien Dictionary (Premium)\nhttps://leetcode.com/problems/alien-dictionary/\n\nGiven a sorted list of words in an alien language, derive the order\nof characters. Return \"\" if the order is invalid.\n\nKey Intuition:\n    Compare adjacent words to extract ordering constraints (edges in a\n    directed graph). Then topological sort (BFS \u2014 Kahn's) to produce the\n    character order. If a cycle exists, the order is invalid.\n\nComplexity (Optimal):\n    Time:  O(C)  \u2014 C = total characters across all words\n    Space: O(1)  \u2014 at most 26 nodes/edges (bounded alphabet)\n\"\"\"\n\nfrom typing import List\nfrom collections import defaultdict, deque\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: BFS topological sort\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        # Step 1: Initialize graph with all unique characters\n        graph = defaultdict(set)\n        in_degree = {ch: 0 for word in words for ch in word}\n\n        # Step 2: Build edges from adjacent word comparisons\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            min_len = min(len(w1), len(w2))\n\n            # Invalid: prefix comes after longer word (e.g. \"abc\" before \"ab\")\n            if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n                return \"\"\n\n            for j in range(min_len):\n                if w1[j] != w2[j]:\n                    if w2[j] not in graph[w1[j]]:\n                        graph[w1[j]].add(w2[j])\n                        in_degree[w2[j]] += 1\n                    break  # only the first difference matters\n\n        # Step 3: Topological sort (Kahn's)\n        queue = deque(ch for ch in in_degree if in_degree[ch] == 0)\n        result = []\n\n        while queue:\n            ch = queue.popleft()\n            result.append(ch)\n            for neighbor in graph[ch]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # If not all characters are in result \u2192 cycle\n        if len(result) != len(in_degree):\n            return \"\"\n        return \"\".join(result)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DFS topological sort with cycle detection\n# Time O(C) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDFS:\n    def alienOrder(self, words: List[str]) -> str:\n        graph = defaultdict(set)\n        in_degree = {ch: 0 for word in words for ch in word}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            min_len = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n                return \"\"\n            for j in range(min_len):\n                if w1[j] != w2[j]:\n                    if w2[j] not in graph[w1[j]]:\n                        graph[w1[j]].add(w2[j])\n                        in_degree[w2[j]] += 1\n                    break\n\n        # DFS-based topological sort\n        WHITE, GRAY, BLACK = 0, 1, 2\n        color = {ch: WHITE for ch in in_degree}\n        order = []\n\n        def dfs(ch):\n            color[ch] = GRAY\n            for neighbor in graph[ch]:\n                if color[neighbor] == GRAY:\n                    return False  # cycle\n                if color[neighbor] == WHITE and not dfs(neighbor):\n                    return False\n            color[ch] = BLACK\n            order.append(ch)\n            return True\n\n        for ch in in_degree:\n            if color[ch] == WHITE:\n                if not dfs(ch):\n                    return \"\"\n\n        return \"\".join(reversed(order))\n",
        "filename": "Alien_Dictionary.py"
      }
    ]
  },
  {
    "name": "Dynamic Programming",
    "icon": "grid_on",
    "problems": [
      {
        "number": 55,
        "title": "Jump Game",
        "url": "https://leetcode.com/problems/jump-game/",
        "intuition": "Track the farthest index reachable so far. Walk left to right; if you can reach position i (i \u2264 farthest), update farthest. If farthest \u2265 last index at any point, return True.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n55. Jump Game\nhttps://leetcode.com/problems/jump-game/\n\nGiven an array nums where nums[i] is the max jump length from position i,\ndetermine if you can reach the last index.\n\nKey Intuition:\n    Track the farthest index reachable so far. Walk left to right; if\n    you can reach position i (i \u2264 farthest), update farthest. If\n    farthest \u2265 last index at any point, return True.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Greedy \u2014 track farthest reachable\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        farthest = 0\n        for i in range(len(nums)):\n            if i > farthest:\n                return False\n            farthest = max(farthest, i + nums[i])\n        return True\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Work backwards \u2014 track last good position\n# Time O(n) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBackward:\n    def canJump(self, nums: List[int]) -> bool:\n        goal = len(nums) - 1\n        for i in range(len(nums) - 2, -1, -1):\n            if i + nums[i] >= goal:\n                goal = i\n        return goal == 0\n",
        "filename": "Jump_Game.py"
      },
      {
        "number": 62,
        "title": "Unique Paths",
        "url": "https://leetcode.com/problems/unique-paths/",
        "intuition": "dp[r][c] = dp[r-1][c] + dp[r][c-1]. The first row and column are all 1's. Can be space\u2011optimized to a single row.",
        "time": "O(m \u00b7 n)",
        "space": "O(n)",
        "code": "\"\"\"\n62. Unique Paths\nhttps://leetcode.com/problems/unique-paths/\n\nA robot on an m \u00d7 n grid starts at top\u2011left and can only move right or\ndown. How many unique paths to the bottom\u2011right?\n\nKey Intuition:\n    dp[r][c] = dp[r-1][c] + dp[r][c-1]. The first row and column are\n    all 1's. Can be space\u2011optimized to a single row.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n)\n    Space: O(n)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: 1D DP (space\u2011optimized)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n        for _ in range(1, m):\n            for c in range(1, n):\n                row[c] += row[c - 1]\n        return row[-1]\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Math \u2014 combination formula C(m+n-2, m-1)\n# Time O(min(m, n)) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfrom math import comb\n\n\nclass SolutionMath:\n    def uniquePaths(self, m: int, n: int) -> int:\n        return comb(m + n - 2, m - 1)\n",
        "filename": "Unique_Paths.py"
      },
      {
        "number": 70,
        "title": "Climbing Stairs",
        "url": "https://leetcode.com/problems/climbing-stairs/",
        "intuition": "dp[i] = dp[i-1] + dp[i-2] \u2014 identical to the Fibonacci sequence. You only need two variables, not an array.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n70. Climbing Stairs\nhttps://leetcode.com/problems/climbing-stairs/\n\nYou can climb 1 or 2 steps at a time. How many distinct ways to reach\nthe top (n steps)?\n\nKey Intuition:\n    dp[i] = dp[i-1] + dp[i-2] \u2014 identical to the Fibonacci sequence.\n    You only need two variables, not an array.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bottom\u2011up with two variables\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        a, b = 1, 2\n        for _ in range(3, n + 1):\n            a, b = b, a + b\n        return b\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Top\u2011down with memoization\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionMemo:\n    def climbStairs(self, n: int) -> int:\n        memo = {}\n\n        def dp(i):\n            if i <= 2:\n                return i\n            if i in memo:\n                return memo[i]\n            memo[i] = dp(i - 1) + dp(i - 2)\n            return memo[i]\n\n        return dp(n)\n",
        "filename": "Climbing_Stairs.py"
      },
      {
        "number": 91,
        "title": "Decode Ways",
        "url": "https://leetcode.com/problems/decode-ways/",
        "intuition": "dp[i] = number of ways to decode s[0:i]. A single digit (1-9) contributes dp[i-1]; a valid two\u2011digit number (10-26) contributes dp[i-2]. Be careful with '0'.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n91. Decode Ways\nhttps://leetcode.com/problems/decode-ways/\n\nA message containing letters A-Z is encoded as '1'-'26'. Given a string\nof digits s, return the number of ways to decode it.\n\nKey Intuition:\n    dp[i] = number of ways to decode s[0:i].\n    A single digit (1-9) contributes dp[i-1]; a valid two\u2011digit number\n    (10-26) contributes dp[i-2]. Be careful with '0'.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bottom\u2011up DP with two variables\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        if not s or s[0] == '0':\n            return 0\n\n        prev2 = 1  # dp[i-2], empty string\n        prev1 = 1  # dp[i-1], first character\n\n        for i in range(1, len(s)):\n            cur = 0\n            # Single digit\n            if s[i] != '0':\n                cur += prev1\n            # Two digits\n            two_digit = int(s[i - 1:i + 1])\n            if 10 <= two_digit <= 26:\n                cur += prev2\n\n            prev2, prev1 = prev1, cur\n\n        return prev1\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Top\u2011down with memoization\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionMemo:\n    def numDecodings(self, s: str) -> int:\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def dp(i):\n            if i == len(s):\n                return 1\n            if s[i] == '0':\n                return 0\n            ways = dp(i + 1)\n            if i + 1 < len(s) and int(s[i:i + 2]) <= 26:\n                ways += dp(i + 2)\n            return ways\n\n        return dp(0)\n",
        "filename": "Decode_Ways.py"
      },
      {
        "number": 139,
        "title": "Word Break",
        "url": "https://leetcode.com/problems/word-break/",
        "intuition": "dp[i] = True if s[0:i] can be segmented. For each position i, check all dictionary words: if dp[i - len(word)] is True and s[i-len(word):i] == word, then dp[i] = True.",
        "time": "O(n\u00b2 \u00b7 m)  \u2014 n = len(s), m = avg word length for comparison",
        "space": "O(n)",
        "code": "\"\"\"\n139. Word Break\nhttps://leetcode.com/problems/word-break/\n\nGiven a string s and a dictionary wordDict, return true if s can be\nsegmented into space\u2011separated dictionary words.\n\nKey Intuition:\n    dp[i] = True if s[0:i] can be segmented. For each position i, check\n    all dictionary words: if dp[i - len(word)] is True and\n    s[i-len(word):i] == word, then dp[i] = True.\n\nComplexity (Optimal):\n    Time:  O(n\u00b2 \u00b7 m)  \u2014 n = len(s), m = avg word length for comparison\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bottom\u2011up DP\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        word_set = set(wordDict)\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True  # empty string\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n\n        return dp[n]\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Top\u2011down with memoization\n# Time O(n\u00b2 \u00b7 m) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionMemo:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        from functools import lru_cache\n        word_set = set(wordDict)\n\n        @lru_cache(maxsize=None)\n        def dp(start):\n            if start == len(s):\n                return True\n            for end in range(start + 1, len(s) + 1):\n                if s[start:end] in word_set and dp(end):\n                    return True\n            return False\n\n        return dp(0)\n",
        "filename": "Word_Break.py"
      },
      {
        "number": 198,
        "title": "House Robber",
        "url": "https://leetcode.com/problems/house-robber/",
        "intuition": "At each house, choose: rob it (add its value to the answer two houses back) or skip it (keep the answer from the previous house). dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n198. House Robber\nhttps://leetcode.com/problems/house-robber/\n\nGiven an array of non\u2011negative integers representing money at each house,\nmaximize the amount you can rob without robbing adjacent houses.\n\nKey Intuition:\n    At each house, choose: rob it (add its value to the answer two houses\n    back) or skip it (keep the answer from the previous house).\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i]).\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Two variables DP\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        prev2, prev1 = 0, 0\n        for num in nums:\n            prev2, prev1 = prev1, max(prev1, prev2 + num)\n        return prev1\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DP array (clearer)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionArray:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n        return dp[-1]\n",
        "filename": "House_Robber.py"
      },
      {
        "number": 213,
        "title": "House Robber II",
        "url": "https://leetcode.com/problems/house-robber-ii/",
        "intuition": "Since houses form a circle, you can never rob both the first and last. Run House Robber I twice: once on nums[1:] and once on nums[:-1]. Take the max of the two.",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n213. House Robber II\nhttps://leetcode.com/problems/house-robber-ii/\n\nSame as House Robber, but the houses are arranged in a circle (first and\nlast houses are adjacent).\n\nKey Intuition:\n    Since houses form a circle, you can never rob both the first and last.\n    Run House Robber I twice: once on nums[1:] and once on nums[:-1].\n    Take the max of the two.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Two passes of House Robber I\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n\n        def rob_linear(houses):\n            prev2, prev1 = 0, 0\n            for h in houses:\n                prev2, prev1 = prev1, max(prev1, prev2 + h)\n            return prev1\n\n        return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DP array version (clearer)\n# Time O(n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionArray:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums)\n\n        def rob_range(lo, hi):\n            dp = [0] * len(nums)\n            dp[lo] = nums[lo]\n            dp[lo + 1] = max(nums[lo], nums[lo + 1])\n            for i in range(lo + 2, hi + 1):\n                dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n            return dp[hi]\n\n        return max(rob_range(0, len(nums) - 2),\n                   rob_range(1, len(nums) - 1))\n",
        "filename": "House_Robber_II.py"
      },
      {
        "number": 300,
        "title": "Longest Increasing Subsequence",
        "url": "https://leetcode.com/problems/longest-increasing-subsequence/",
        "intuition": "",
        "time": "O(n log n)",
        "space": "O(n)",
        "code": "\"\"\"\n300. Longest Increasing Subsequence\nhttps://leetcode.com/problems/longest-increasing-subsequence/\n\nGiven an integer array nums, return the length of the longest strictly\nincreasing subsequence.\n\nKey Intuition (O(n log n)):\n    Maintain a \"tails\" array where tails[i] is the smallest tail\n    element for an increasing subsequence of length i+1. For each num,\n    binary search to find its position in tails. This gives O(n log n).\n\nComplexity (Optimal):\n    Time:  O(n log n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\nimport bisect\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Patience sorting / binary search on tails\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        tails = []\n        for num in nums:\n            pos = bisect.bisect_left(tails, num)\n            if pos == len(tails):\n                tails.append(num)\n            else:\n                tails[pos] = num\n        return len(tails)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Classic DP\n# Time O(n\u00b2) \u00b7 Space O(n)\n# dp[i] = LIS ending at index i\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDP:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n",
        "filename": "Longest_Increasing_Subsequence.py"
      },
      {
        "number": 322,
        "title": "Coin Change",
        "url": "https://leetcode.com/problems/coin-change/",
        "intuition": "dp[a] = minimum coins to make amount a. For each amount from 1 to target, try every coin: dp[a] = min(dp[a], dp[a - coin] + 1) Base case: dp[0] = 0.",
        "time": "O(amount \u00d7 len(coins))",
        "space": "O(amount)",
        "code": "\"\"\"\n322. Coin Change\nhttps://leetcode.com/problems/coin-change/\n\nGiven coins of different denominations and a total amount, return the\nfewest number of coins needed. Return -1 if not possible.\n\nKey Intuition:\n    dp[a] = minimum coins to make amount a.\n    For each amount from 1 to target, try every coin:\n        dp[a] = min(dp[a], dp[a - coin] + 1)\n    Base case: dp[0] = 0.\n\nComplexity (Optimal):\n    Time:  O(amount \u00d7 len(coins))\n    Space: O(amount)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bottom\u2011up DP\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount + 1):\n            for coin in coins:\n                if coin <= a:\n                    dp[a] = min(dp[a], dp[a - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Top\u2011down with memoization\n# Time O(amount \u00d7 len(coins)) \u00b7 Space O(amount)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionMemo:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def dp(remaining):\n            if remaining == 0:\n                return 0\n            if remaining < 0:\n                return float('inf')\n            return min((dp(remaining - c) for c in coins), default=float('inf')) + 1\n\n        result = dp(amount)\n        return result if result != float('inf') else -1\n",
        "filename": "Coin_Change.py"
      },
      {
        "number": 377,
        "title": "Combination Sum IV",
        "url": "https://leetcode.com/problems/combination-sum-iv/",
        "intuition": "dp[t] = number of ways to reach sum t. For each target from 1..target, try every num: dp[t] += dp[t - num].  This is the \"unbounded knapsack with order\" variant.",
        "time": "O(target \u00d7 len(nums))",
        "space": "O(target)",
        "code": "\"\"\"\n377. Combination Sum IV\nhttps://leetcode.com/problems/combination-sum-iv/\n\nGiven an array of distinct positive integers nums and a target, return\nthe number of possible combinations that add up to target.\n(Order matters \u2014 this is really counting permutations.)\n\nKey Intuition:\n    dp[t] = number of ways to reach sum t. For each target from 1..target,\n    try every num: dp[t] += dp[t - num].  This is the \"unbounded knapsack\n    with order\" variant.\n\nComplexity (Optimal):\n    Time:  O(target \u00d7 len(nums))\n    Space: O(target)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bottom\u2011up DP\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        dp = [0] * (target + 1)\n        dp[0] = 1\n\n        for t in range(1, target + 1):\n            for num in nums:\n                if num <= t:\n                    dp[t] += dp[t - num]\n\n        return dp[target]\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Top\u2011down with memoization\n# Time O(target \u00d7 len(nums)) \u00b7 Space O(target)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionMemo:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def dp(remaining):\n            if remaining == 0:\n                return 1\n            if remaining < 0:\n                return 0\n            return sum(dp(remaining - num) for num in nums)\n\n        return dp(target)\n",
        "filename": "Combination_Sum_IV.py"
      },
      {
        "number": 1143,
        "title": "Longest Common Subsequence",
        "url": "https://leetcode.com/problems/longest-common-subsequence/",
        "intuition": "2D DP: if characters match, dp[i][j] = dp[i-1][j-1] + 1; otherwise take the max of skipping either character. Can be space\u2011optimized to one row.",
        "time": "O(m \u00b7 n)",
        "space": "O(min(m, n))  \u2014 single row optimization",
        "code": "\"\"\"\n1143. Longest Common Subsequence\nhttps://leetcode.com/problems/longest-common-subsequence/\n\nGiven two strings text1 and text2, return the length of their longest\ncommon subsequence (LCS).\n\nKey Intuition:\n    2D DP: if characters match, dp[i][j] = dp[i-1][j-1] + 1;\n    otherwise take the max of skipping either character.\n    Can be space\u2011optimized to one row.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n)\n    Space: O(min(m, n))  \u2014 single row optimization\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bottom\u2011up DP (space\u2011optimized)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        # Ensure text2 is the shorter string for space optimization\n        if len(text1) < len(text2):\n            text1, text2 = text2, text1\n\n        prev = [0] * (len(text2) + 1)\n\n        for i in range(1, len(text1) + 1):\n            cur = [0] * (len(text2) + 1)\n            for j in range(1, len(text2) + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    cur[j] = prev[j - 1] + 1\n                else:\n                    cur[j] = max(prev[j], cur[j - 1])\n            prev = cur\n\n        return prev[-1]\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Full 2D DP table (easier to understand)\n# Time O(m \u00b7 n) \u00b7 Space O(m \u00b7 n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionFull2D:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[m][n]\n",
        "filename": "Longest_Common_Subsequence.py"
      }
    ]
  },
  {
    "name": "Intervals",
    "icon": "date_range",
    "problems": [
      {
        "number": 56,
        "title": "Merge Intervals",
        "url": "https://leetcode.com/problems/merge-intervals/",
        "intuition": "Sort by start time. Walk through intervals: if the current interval overlaps with the last merged one, extend its end; otherwise start a new merged interval.",
        "time": "O(n log n)  \u2014 sorting dominates",
        "space": "O(n)        \u2014 for the output",
        "code": "\"\"\"\n56. Merge Intervals\nhttps://leetcode.com/problems/merge-intervals/\n\nGiven an array of intervals, merge all overlapping intervals.\n\nKey Intuition:\n    Sort by start time. Walk through intervals: if the current interval\n    overlaps with the last merged one, extend its end; otherwise start\n    a new merged interval.\n\nComplexity (Optimal):\n    Time:  O(n log n)  \u2014 sorting dominates\n    Space: O(n)        \u2014 for the output\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Sort + linear merge\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort()\n        merged = [intervals[0]]\n\n        for start, end in intervals[1:]:\n            if start <= merged[-1][1]:\n                merged[-1][1] = max(merged[-1][1], end)\n            else:\n                merged.append([start, end])\n\n        return merged\n",
        "filename": "Merge_Intervals.py"
      },
      {
        "number": 57,
        "title": "Insert Interval",
        "url": "https://leetcode.com/problems/insert-interval/",
        "intuition": "Walk through intervals in three phases: 1. Add all intervals that end before the new one starts. 2. Merge all overlapping intervals with the new one. 3. Add remaining intervals.",
        "time": "O(n)",
        "space": "O(n)  \u2014 for the output",
        "code": "\"\"\"\n57. Insert Interval\nhttps://leetcode.com/problems/insert-interval/\n\nGiven a sorted list of non\u2011overlapping intervals and a new interval,\ninsert and merge if necessary.\n\nKey Intuition:\n    Walk through intervals in three phases:\n    1. Add all intervals that end before the new one starts.\n    2. Merge all overlapping intervals with the new one.\n    3. Add remaining intervals.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)  \u2014 for the output\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Linear scan + merge\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def insert(\n        self, intervals: List[List[int]], newInterval: List[int]\n    ) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. Add all intervals before newInterval\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. Merge overlapping intervals\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n\n        # 3. Add remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n",
        "filename": "Insert_Interval.py"
      },
      {
        "number": 252,
        "title": "Meeting Rooms",
        "url": "https://leetcode.com/problems/meeting-rooms/",
        "intuition": "Sort by start time. If any meeting starts before the previous one ends, there's a conflict.",
        "time": "O(n log n)",
        "space": "O(1)",
        "code": "\"\"\"\n252. Meeting Rooms (Premium)\nhttps://leetcode.com/problems/meeting-rooms/\n\nGiven an array of meeting time intervals, determine if a person could\nattend all meetings (no two meetings overlap).\n\nKey Intuition:\n    Sort by start time. If any meeting starts before the previous one\n    ends, there's a conflict.\n\nComplexity (Optimal):\n    Time:  O(n log n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Sort + linear check\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        intervals.sort()\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i - 1][1]:\n                return False\n        return True\n",
        "filename": "Meeting_Rooms.py"
      },
      {
        "number": 253,
        "title": "Meeting Rooms II",
        "url": "https://leetcode.com/problems/meeting-rooms-ii/",
        "intuition": "Treat starts and ends as events on a timeline. Sort all start/end times. Walk through: +1 room at each start, \u22121 at each end. The peak count is the answer. Alternatively, use a min\u2011heap of end times.",
        "time": "O(n log n)",
        "space": "O(n)",
        "code": "\"\"\"\n253. Meeting Rooms II (Premium)\nhttps://leetcode.com/problems/meeting-rooms-ii/\n\nGiven an array of meeting time intervals, find the minimum number of\nconference rooms required.\n\nKey Intuition:\n    Treat starts and ends as events on a timeline. Sort all start/end\n    times. Walk through: +1 room at each start, \u22121 at each end.\n    The peak count is the answer. Alternatively, use a min\u2011heap of\n    end times.\n\nComplexity (Optimal):\n    Time:  O(n log n)\n    Space: O(n)\n\"\"\"\n\nfrom typing import List\nimport heapq\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Min\u2011heap of end times\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n\n        intervals.sort()\n        heap = []  # end times of ongoing meetings\n\n        for start, end in intervals:\n            # If earliest ending meeting is done before this one starts,\n            # reuse that room\n            if heap and heap[0] <= start:\n                heapq.heappop(heap)\n            heapq.heappush(heap, end)\n\n        return len(heap)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Chronological event sweep\n# Time O(n log n) \u00b7 Space O(n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSweep:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        starts = sorted(i[0] for i in intervals)\n        ends = sorted(i[1] for i in intervals)\n\n        rooms = 0\n        end_ptr = 0\n        for start in starts:\n            if start < ends[end_ptr]:\n                rooms += 1\n            else:\n                end_ptr += 1\n        return rooms\n",
        "filename": "Meeting_Rooms_II.py"
      },
      {
        "number": 435,
        "title": "Non Overlapping Intervals",
        "url": "https://leetcode.com/problems/non-overlapping-intervals/",
        "intuition": "Sort by end time (greedy \"activity selection\"). Always keep the interval that ends earliest \u2014 it leaves the most room for future intervals. Count how many you must remove.",
        "time": "O(n log n)",
        "space": "O(1)",
        "code": "\"\"\"\n435. Non\u2011overlapping Intervals\nhttps://leetcode.com/problems/non-overlapping-intervals/\n\nGiven an array of intervals, return the minimum number of intervals\nyou need to remove to make the rest non\u2011overlapping.\n\nKey Intuition:\n    Sort by end time (greedy \"activity selection\"). Always keep the\n    interval that ends earliest \u2014 it leaves the most room for future\n    intervals. Count how many you must remove.\n\nComplexity (Optimal):\n    Time:  O(n log n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Greedy \u2014 sort by end time\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        removals = 0\n        prev_end = float('-inf')\n\n        for start, end in intervals:\n            if start < prev_end:\n                removals += 1     # overlap \u2192 remove this one\n            else:\n                prev_end = end    # no overlap \u2192 keep it\n\n        return removals\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Sort by start time, track removals differently\n# Time O(n log n) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSortByStart:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        removals = 0\n        prev_end = intervals[0][1]\n\n        for start, end in intervals[1:]:\n            if start < prev_end:\n                removals += 1\n                prev_end = min(prev_end, end)  # keep the one ending earlier\n            else:\n                prev_end = end\n\n        return removals\n",
        "filename": "Non_Overlapping_Intervals.py"
      }
    ]
  },
  {
    "name": "Math and Geometry",
    "icon": "functions",
    "problems": [
      {
        "number": 48,
        "title": "Rotate Image",
        "url": "https://leetcode.com/problems/rotate-image/",
        "intuition": "Transpose the matrix (swap rows \u2194 columns), then reverse each row. Transpose + reverse = 90\u00b0 clockwise rotation.",
        "time": "O(n\u00b2)",
        "space": "O(1)  \u2014 in\u2011place",
        "code": "\"\"\"\n48. Rotate Image\nhttps://leetcode.com/problems/rotate-image/\n\nRotate an n \u00d7 n 2D matrix 90 degrees clockwise in\u2011place.\n\nKey Intuition:\n    Transpose the matrix (swap rows \u2194 columns), then reverse each row.\n    Transpose + reverse = 90\u00b0 clockwise rotation.\n\nComplexity (Optimal):\n    Time:  O(n\u00b2)\n    Space: O(1)  \u2014 in\u2011place\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Transpose + reverse rows\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        # Transpose\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        # Reverse each row\n        for row in matrix:\n            row.reverse()\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Four\u2011way swap (rotate groups of 4 cells)\n# Time O(n\u00b2) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionFourWay:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - 1 - i):\n                # Save top\n                tmp = matrix[i][j]\n                # left \u2192 top\n                matrix[i][j] = matrix[n - 1 - j][i]\n                # bottom \u2192 left\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]\n                # right \u2192 bottom\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n                # top \u2192 right\n                matrix[j][n - 1 - i] = tmp\n",
        "filename": "Rotate_Image.py"
      },
      {
        "number": 54,
        "title": "Spiral Matrix",
        "url": "https://leetcode.com/problems/spiral-matrix/",
        "intuition": "Maintain four boundaries (top, bottom, left, right). Traverse: left\u2192right along top, top\u2192bottom along right, right\u2192left along bottom, bottom\u2192top along left. Shrink boundaries after each pass.",
        "time": "O(m \u00b7 n)",
        "space": "O(1)  \u2014 ignoring output",
        "code": "\"\"\"\n54. Spiral Matrix\nhttps://leetcode.com/problems/spiral-matrix/\n\nGiven an m \u00d7 n matrix, return all elements in spiral order.\n\nKey Intuition:\n    Maintain four boundaries (top, bottom, left, right). Traverse:\n    left\u2192right along top, top\u2192bottom along right, right\u2192left along\n    bottom, bottom\u2192top along left. Shrink boundaries after each pass.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n)\n    Space: O(1)  \u2014 ignoring output\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Layer\u2011by\u2011layer with boundaries\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        result = []\n        top, bottom = 0, len(matrix) - 1\n        left, right = 0, len(matrix[0]) - 1\n\n        while top <= bottom and left <= right:\n            # Traverse right\n            for c in range(left, right + 1):\n                result.append(matrix[top][c])\n            top += 1\n\n            # Traverse down\n            for r in range(top, bottom + 1):\n                result.append(matrix[r][right])\n            right -= 1\n\n            # Traverse left\n            if top <= bottom:\n                for c in range(right, left - 1, -1):\n                    result.append(matrix[bottom][c])\n                bottom -= 1\n\n            # Traverse up\n            if left <= right:\n                for r in range(bottom, top - 1, -1):\n                    result.append(matrix[r][left])\n                left += 1\n\n        return result\n",
        "filename": "Spiral_Matrix.py"
      },
      {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "url": "https://leetcode.com/problems/set-matrix-zeroes/",
        "intuition": "Use the first row and first column as markers. If matrix[i][j] == 0, set matrix[i][0] = 0 and matrix[0][j] = 0. Then make a second pass to zero out marked rows/columns. Handle the first row/col separately with boolean flags.",
        "time": "O(m \u00b7 n)",
        "space": "O(1)",
        "code": "\"\"\"\n73. Set Matrix Zeroes\nhttps://leetcode.com/problems/set-matrix-zeroes/\n\nGiven an m \u00d7 n matrix, if an element is 0, set its entire row and column\nto 0. Do it in\u2011place.\n\nKey Intuition:\n    Use the first row and first column as markers. If matrix[i][j] == 0,\n    set matrix[i][0] = 0 and matrix[0][j] = 0. Then make a second pass\n    to zero out marked rows/columns. Handle the first row/col separately\n    with boolean flags.\n\nComplexity (Optimal):\n    Time:  O(m \u00b7 n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Use first row/col as markers\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        m, n = len(matrix), len(matrix[0])\n        first_row_zero = any(matrix[0][j] == 0 for j in range(n))\n        first_col_zero = any(matrix[i][0] == 0 for i in range(m))\n\n        # Mark zeros in first row/col\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n\n        # Zero out cells based on markers\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        # Handle first row\n        if first_row_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n\n        # Handle first column\n        if first_col_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Record zero positions with sets\n# Time O(m \u00b7 n) \u00b7 Space O(m + n)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionSets:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        m, n = len(matrix), len(matrix[0])\n        zero_rows = set()\n        zero_cols = set()\n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    zero_rows.add(i)\n                    zero_cols.add(j)\n\n        for i in range(m):\n            for j in range(n):\n                if i in zero_rows or j in zero_cols:\n                    matrix[i][j] = 0\n",
        "filename": "Set_Matrix_Zeroes.py"
      }
    ]
  },
  {
    "name": "Bit Manipulation",
    "icon": "memory",
    "problems": [
      {
        "number": 190,
        "title": "Reverse Bits",
        "url": "https://leetcode.com/problems/reverse-bits/",
        "intuition": "Extract the last bit of n, place it at the correct position in the result, shift n right. Repeat 32 times.",
        "time": "O(1)  \u2014 always 32 iterations",
        "space": "O(1)",
        "code": "\"\"\"\n190. Reverse Bits\nhttps://leetcode.com/problems/reverse-bits/\n\nReverse the bits of a 32\u2011bit unsigned integer.\n\nKey Intuition:\n    Extract the last bit of n, place it at the correct position in the\n    result, shift n right. Repeat 32 times.\n\nComplexity (Optimal):\n    Time:  O(1)  \u2014 always 32 iterations\n    Space: O(1)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bit\u2011by\u2011bit reversal\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def reverseBits(self, n: int) -> int:\n        result = 0\n        for _ in range(32):\n            result = (result << 1) | (n & 1)\n            n >>= 1\n        return result\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Divide and conquer (swap halves recursively)\n# Time O(1) \u00b7 Space O(1) \u2014 5 operations on 32-bit word\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionDivideConquer:\n    def reverseBits(self, n: int) -> int:\n        n = ((n & 0xFFFF0000) >> 16) | ((n & 0x0000FFFF) << 16)\n        n = ((n & 0xFF00FF00) >> 8)  | ((n & 0x00FF00FF) << 8)\n        n = ((n & 0xF0F0F0F0) >> 4)  | ((n & 0x0F0F0F0F) << 4)\n        n = ((n & 0xCCCCCCCC) >> 2)  | ((n & 0x33333333) << 2)\n        n = ((n & 0xAAAAAAAA) >> 1)  | ((n & 0x55555555) << 1)\n        return n\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Pythonic\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionPythonic:\n    def reverseBits(self, n: int) -> int:\n        return int(bin(n)[2:].zfill(32)[::-1], 2)\n",
        "filename": "Reverse_Bits.py"
      },
      {
        "number": 191,
        "title": "Number of 1 Bits",
        "url": "https://leetcode.com/problems/number-of-1-bits/",
        "intuition": "n & (n - 1) clears the lowest set bit. Repeat until n becomes 0; the number of iterations equals the number of 1 bits.",
        "time": "O(k) \u2014 k = number of set bits",
        "space": "O(1)",
        "code": "\"\"\"\n191. Number of 1 Bits (Hamming Weight)\nhttps://leetcode.com/problems/number-of-1-bits/\n\nGiven a positive integer, return the number of set bits (1s) in its\nbinary representation.\n\nKey Intuition:\n    n & (n - 1) clears the lowest set bit. Repeat until n becomes 0;\n    the number of iterations equals the number of 1 bits.\n\nComplexity (Optimal):\n    Time:  O(k) \u2014 k = number of set bits\n    Space: O(1)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Brian Kernighan's trick\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Check each bit\n# Time O(32) = O(1) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionShift:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Pythonic one-liner\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionBuiltin:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')\n",
        "filename": "Number_of_1_Bits.py"
      },
      {
        "number": 268,
        "title": "Missing Number",
        "url": "https://leetcode.com/problems/missing-number/",
        "intuition": "XOR all indices 0..n with all values in nums. Pairs cancel out; the remaining value is the missing number. Alternatively, use the Gauss sum formula: n(n+1)/2 \u2212 sum(nums).",
        "time": "O(n)",
        "space": "O(1)",
        "code": "\"\"\"\n268. Missing Number\nhttps://leetcode.com/problems/missing-number/\n\nGiven an array nums containing n distinct numbers in [0, n], return\nthe one number in the range that is missing.\n\nKey Intuition:\n    XOR all indices 0..n with all values in nums. Pairs cancel out;\n    the remaining value is the missing number. Alternatively, use\n    the Gauss sum formula: n(n+1)/2 \u2212 sum(nums).\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(1)\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Gauss summation\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        return n * (n + 1) // 2 - sum(nums)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: XOR\n# Time O(n) \u00b7 Space O(1)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionXOR:\n    def missingNumber(self, nums: List[int]) -> int:\n        xor = len(nums)\n        for i, num in enumerate(nums):\n            xor ^= i ^ num\n        return xor\n",
        "filename": "Missing_Number.py"
      },
      {
        "number": 338,
        "title": "Counting Bits",
        "url": "https://leetcode.com/problems/counting-bits/",
        "intuition": "dp[i] = dp[i >> 1] + (i & 1). Shifting right drops the last bit, which we add back with (i & 1). Each value builds on a previously computed one.",
        "time": "O(n)",
        "space": "O(n)  \u2014 the output",
        "code": "\"\"\"\n338. Counting Bits\nhttps://leetcode.com/problems/counting-bits/\n\nGiven an integer n, return an array ans where ans[i] is the number of\n1's in the binary representation of i, for 0 \u2264 i \u2264 n.\n\nKey Intuition:\n    dp[i] = dp[i >> 1] + (i & 1). Shifting right drops the last bit,\n    which we add back with (i & 1). Each value builds on a previously\n    computed one.\n\nComplexity (Optimal):\n    Time:  O(n)\n    Space: O(n)  \u2014 the output\n\"\"\"\n\nfrom typing import List\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: DP with bit shift\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: DP using i & (i-1) \u2014 strips last set bit\n# Time O(n) \u00b7 Space O(n)\n# dp[i] = dp[i & (i-1)] + 1\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionKernighan:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i & (i - 1)] + 1\n        return dp\n",
        "filename": "Counting_Bits.py"
      },
      {
        "number": 371,
        "title": "Sum of Two Integers",
        "url": "https://leetcode.com/problems/sum-of-two-integers/",
        "intuition": "XOR gives the sum without carries. AND + left shift gives the carries. Repeat until there are no carries. In Python, integers are arbitrary\u2011 precision, so mask to 32 bits to simulate overflow.",
        "time": "O(1)  \u2014 at most 32 iterations",
        "space": "O(1)",
        "code": "\"\"\"\n371. Sum of Two Integers\nhttps://leetcode.com/problems/sum-of-two-integers/\n\nCalculate the sum of two integers a and b without using + or -.\n\nKey Intuition:\n    XOR gives the sum without carries. AND + left shift gives the carries.\n    Repeat until there are no carries. In Python, integers are arbitrary\u2011\n    precision, so mask to 32 bits to simulate overflow.\n\nComplexity (Optimal):\n    Time:  O(1)  \u2014 at most 32 iterations\n    Space: O(1)\n\"\"\"\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Optimal: Bit manipulation (32\u2011bit simulation)\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass Solution:\n    def getSum(self, a: int, b: int) -> int:\n        MASK = 0xFFFFFFFF   # 32-bit mask\n        MAX  = 0x7FFFFFFF   # max positive 32-bit int\n\n        while b & MASK:\n            carry = (a & b) << 1\n            a = a ^ b\n            b = carry\n\n        # If b is 0 (no more carry), return a masked to 32 bits.\n        # Handle negative numbers: if a > MAX, it's negative in 32-bit.\n        a = a & MASK\n        return a if a <= MAX else ~(a ^ MASK)\n\n\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Alternative: Recursive version\n# Same logic, recursive form\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nclass SolutionRecursive:\n    def getSum(self, a: int, b: int) -> int:\n        MASK = 0xFFFFFFFF\n        MAX  = 0x7FFFFFFF\n\n        if b == 0:\n            return a if a <= MAX else ~(a ^ MASK)\n\n        return self.getSum((a ^ b) & MASK, ((a & b) << 1) & MASK)\n",
        "filename": "Sum_of_Two_Integers.py"
      }
    ]
  }
];
